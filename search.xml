<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>表征学习、以及PCA的细节公式推导</title>
      <link href="/2021/04/20/rl-pca/"/>
      <url>/2021/04/20/rl-pca/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Representation-Learning-表征学习"><a href="#Representation-Learning-表征学习" class="headerlink" title="Representation Learning 表征学习"></a>Representation Learning 表征学习</h1><blockquote><p>这章将稍微讲讲表征学习，以及经典方法PCA。公式显示出现了一些问题，建议需要的阅读的可以先到 <a href="https://blog.csdn.net/chitoseyono/article/details/116021374" target="_blank" rel="noopener">https://blog.csdn.net/chitoseyono/article/details/116021374</a> 顺畅查阅。</p><p>机器学习算法的与否可行不仅仅取决于算法的正确选用，也取决于数据的质量和有效的数据表示（representation）。针对不同类型的数据（text，image，video），错误的表示方式可能会导致有效信息的缺失或是暴露，这决定了算法能否有效地解决问题。表征学习的目的是对复杂的原始数据化繁为简，把原始数据的无效的或者冗余的信息剔除，把有效信息进行提炼，形成特征（feature）。特征提取可以人为地手工处理，也可以借助特定的算法自动提取。Roughly Speaking， 前者（手动处理）称为特征工程，后者（借助算法）为表征学习（Representation Learning）。如果数据量较小，我们可以根据自身的经验和先验知识，人为地设计出合适的特征，用作下游的任务，比如分类；但数据量很大且复杂时，则需要依赖自动化的表征学习。</p><p>注意，这之后的章节内容都可能比较混乱/缺失，我尽量会把算法的关键思想说清，但是公式推导会有点跳步，请尽量搭配对每一章应参考资料查阅。</p><ol><li>表征学习：<a href="https://zhuanlan.zhihu.com/p/136554341" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/136554341</a></li><li>流形学习：<a href="https://scikit-learn.org/stable/modules/manifold.htm" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/manifold.htm</a></li><li>稀疏表示，特征提取，特征选择：西瓜书</li><li>van der Maaten, Laurens &amp; Postma, Eric &amp; Herik, H.. (2007). Dimensionality Reduction: A Comparative Review. Journal of Machine Learning Research - JMLR. 10. </li><li>Anowar, Farzana &amp; Sadaoui, Samira &amp; Selim, Bassant. (2021). Conceptual and empirical comparison of dimensionality reduction algorithms (PCA, KPCA, LDA, MDS, SVD, LLE, ISOMAP, LE, ICA, t-SNE). Computer Science Review. 40. 10.1016/j.cosrev.2021.100378. </li></ol></blockquote><p>Representation Learning要做的一般有：</p><ul><li>Dimension Reduction 降维</li><li>Manifold Learning 流式学习</li><li>Sparse Representation 稀疏表示</li></ul><p><strong>目的</strong>：</p><ul><li>减少算法训练/学习的开销，避免<strong>维数灾难</strong></li><li>让数据更好可视化，更好理解与Debug</li><li>降低数据存储</li></ul><h3 id="The-curse-of-dimensionality-维数灾难"><a href="#The-curse-of-dimensionality-维数灾难" class="headerlink" title="The curse of dimensionality 维数灾难"></a>The curse of dimensionality 维数灾难</h3><blockquote><p>在kNN上，我们发现任意测试样本 $x$ 附近任意小的 $δ$ 距离范围内，总能找到一个训练样本，即训练样本的采样密度足够大，或称为“密采样”(dense sample)。然而，这个假设在现实任务中通常很难满足，例如 $δ=0.001$，仅考虑单个属性，则仅需1000个样本点平均分布在归一化后的属性取值范围内，即可使得任意测试样本在其附近0.001距离范围内总能找到一个训练样本。此时最近邻分类器的错误率不超过贝叶斯最优分类器的错误率的两倍。然而，这仅是属性维数为1的情形。若有更多的属性，则情况会发生显著变化。例如假定属性维数为20，若要求样本满足密采样条件，则至少需要$1000^{20}=10^{60}$个样本。现实应用中属性维数经常成千上万，要满足密采样条件约为所需的样本数目是无法达到的天文数字。此外，许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，当维数很高时甚至连计算内积都不再容易。</p><p>事实上，在高位情形下出现的数据样本稀疏、距离计算困难问题，是所有机器学习方法的共通障碍——<strong>维数灾难</strong>。</p></blockquote><h3 id="Feature-Extraction-vs-Feature-Selection-特征提取-vs-特征选择"><a href="#Feature-Extraction-vs-Feature-Selection-特征提取-vs-特征选择" class="headerlink" title="Feature Extraction vs Feature Selection 特征提取 vs 特征选择"></a>Feature Extraction vs Feature Selection 特征提取 vs 特征选择</h3><p><img src="/2021/04/21/rl-pca/features_change.png" alt="features"></p><p><strong>Feature Extraction</strong> are ways to transform/project the original features in the data into new features which have some advantage such as</p><ul><li>Lower Dimensionality</li><li>Better description of the variance in the data</li><li>Better ability to distinguish data points or clusters of data points</li></ul><p>Whereas <strong>Feature Selection</strong> is attempt to find a subset of the original features which <strong>satisfy some criteria</strong>.  Ideally the selected subset includes the <strong>significant features</strong> and <strong>eliminates irrelevant and redundant</strong> features.</p><p>Methods of Feature Selection</p><ul><li>Feature Ranking</li><li>Filter Approach, 如 Relevant Features (Relief)</li><li>Wrapper approach, 如 Las Vegas Wrapper (LVW)</li><li>Embedding approach</li></ul><p>This Chapter is focus on <strong>Feature Extraction</strong>, though feature selection is needed to learned as when comes to some data analysis tasks.</p><p><strong>Methods of Feature Extraction</strong></p><ul><li>Linear Methods:<ul><li>Unsupervised<ul><li>PCA</li><li>ICA</li></ul></li><li>Supervised<ul><li>LDA</li></ul></li></ul></li><li>Non-linear Methods:<ul><li>Global <em>(preserve global properties)</em><ul><li>MDS</li><li>Isomap</li><li>Kernel PCA</li></ul></li><li>Local <em>(preserve properties within local neighborhood)</em><ul><li>LLE</li></ul></li><li>Global + Local<ul><li>SNE</li></ul></li></ul></li></ul><p>简单比较他们的性质：</p><p><img src="/2021/04/21/rl-pca/comparison1.png" alt="compare1"></p><p><img src="/2021/04/21/rl-pca/comparison2.png" alt="compare2"></p><h1 id="Principal-Component-Analysis-主成分分析"><a href="#Principal-Component-Analysis-主成分分析" class="headerlink" title="Principal Component Analysis 主成分分析"></a>Principal Component Analysis 主成分分析</h1><blockquote><p>参考资料：</p><ol><li>西瓜书 10.3</li><li>拉格朗日函数：<a href="https://math.stackexchange.com/questions/1104376/how-to-set-up-lagrangian-optimization-with-matrix-constrains" target="_blank" rel="noopener">https://math.stackexchange.com/questions/1104376/how-to-set-up-lagrangian-optimization-with-matrix-constrains</a></li><li>Unsupervised and Supervised Principal Component Analysis: Tutorial</li><li>花书 2.7, 2.8</li><li>M. Turk and A. Pentland, “Eigenfaces for recognition,” Journal of cognitive neuroscience, vol. 3, no. 1, pp. 71–86, 1991.</li><li>M. A. Turk and A. P. Pentland, “Face recognition using eigenfaces,” in Computer Vision and Pattern Recognition, 1991. Proceedings CVPR’91., IEEE Computer Society Conference on, pp. 586–591, IEEE, 1991.</li><li>视觉化：<a href="https://setosa.io/ev/principal-component-analysis/" target="_blank" rel="noopener">https://setosa.io/ev/principal-component-analysis/</a></li></ol></blockquote><p>PCA降维的核心思想是：找到最有影响力，使全部样本最大可分的向量（即方差最大的），作为主成分，然后映射到该向量去。对其求垂直便能找到第二个主成分，然后找到k个主成分后，那么原来n维可以降到k维。</p><p>主要做法有Eigen-decomposition（特征值分解）与Singular Value Decomposition（奇异值分解），后者被称为Dual PCA。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="Preprocessing-预处理"><a href="#Preprocessing-预处理" class="headerlink" title="Preprocessing 预处理"></a>Preprocessing 预处理</h3><p><strong>Train Set</strong>：$\mathbf{X}\in \mathbb{R}^{d\times n} = [X_1,\cdots,X_n] = {X_i\in \mathbb{R}^d}_{i=1}^n$ </p><p><strong>Mean</strong>：$\mu=\frac{1}{n}\sum^n_{i=1} X_i \in \mathbb{R}^d$</p><p><strong>Normalization</strong>：$\breve{\mathbf{X}}=\mathbf{X}-\mu =\mathbf{X}·H$（这里是用线性变换的方法近似归一化效果，减少运算量，其中$H=I-(1/n)11^T$，$1$是全1向量。$H$被称为 <strong><a href="https://en.wikipedia.org/wiki/Centering_matrix" target="_blank" rel="noopener">centering matrix</a></strong>）</p><p>（其中对于NLP的任务不需要归一化，因为NLP中负数是无意义的，这时就称为LSI/LSA）</p><h3 id="投影-Projection-与-还原-Reconstruction"><a href="#投影-Projection-与-还原-Reconstruction" class="headerlink" title="投影 Projection 与 还原 Reconstruction"></a>投影 Projection 与 还原 Reconstruction</h3><p>我们的目的是找到映射矩阵 $\mathbf{U}\in\R^{d<em>p}$，将数据从 $\R^{d</em>n}$ 映射到 $\R^{p*n}$。</p><p><strong>Projection</strong>：$\mathbf{\tilde{X}} = \mathbf{U}^T\mathbf{\breve{X}},\mathbf{\tilde{X}}\in \mathbb{R}^{p\times n}$</p><p><strong>Reconstruction</strong>：$\mathbf{\hat{X}}=\mathbf{U}\mathbf{U}^T\mathbf{\breve{X}}+\mu=\mathbf{U}\mathbf{\tilde{X}}+\mu$</p><p><strong>Test Set：</strong>$\mathbf{\tilde{X_t}} = \mathbf{U}^T\mathbf{\breve{X}},\mathbf{\hat{X_t}}=\mathbf{U}\mathbf{\tilde{X_t}}+\mu_x$（相当于用训练出的投影矩阵处理测试集）</p><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p>为寻找优化目标，我们从两个角度去看主成分分析算法。分别是<strong>最小化重构Error（最近重构性）</strong>和<strong>最大方差（最大可分性）</strong>，他们能够得出一样的结果。</p><h3 id="1-最大化方差"><a href="#1-最大化方差" class="headerlink" title="1 最大化方差"></a>1 最大化方差</h3><p>根据最大可分性，我们希望重构后数据的方差会尽量的大。我们将作为constant项的$\mu$去掉，取其<strong>Square Frobenius Norm</strong>，有：<br>$$<br>\begin{array}{l}\left|\hat{\mathbf{X}}\right|<em>{F}^{2} = \left|\boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right|</em>{F}^{2} \=\operatorname{tr}\left(\left(\boldsymbol{U} \boldsymbol{U}^{\top}\breve{\boldsymbol{X}}\right)^{\top}\left(\boldsymbol{U}\boldsymbol{U}^{\top}\breve{\boldsymbol{X}}\right)\right) \=\operatorname{tr}(\breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \underbrace{\boldsymbol{U}^{\top}\boldsymbol{U}}_{\boldsymbol{I}}\boldsymbol{U}^{\top}\breve{\boldsymbol{X}})\=\operatorname{tr}\left(\breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right)\=\operatorname{tr}\left(\boldsymbol{U}^{\top}\breve{\boldsymbol{X}}\breve{\boldsymbol{X}}^{\top}\boldsymbol{U}  \right) \end{array}<br>$$<br><strong>Minimization</strong>（常规做法会用到拉格朗日函数，最好查看参考链接[3]理解这一步）：<br>$$<br>\begin{aligned}<br>&amp;\underset{\boldsymbol{U}}{\operatorname{minimize}}\operatorname{tr}\left(\boldsymbol{U}^{\top}\breve{\boldsymbol{X}}\breve{\boldsymbol{X}}^{\top} \boldsymbol{U}  \right)  \<br>&amp;\text { subject to } \boldsymbol{U}^{\top} \boldsymbol{U}=\boldsymbol{I} \<br>\end{aligned}<br>$$</p><p>$$<br>\mathcal{L}=\operatorname{tr}\left(\boldsymbol{U}^{\top}\breve{\boldsymbol{X}}\breve{\boldsymbol{X}}^{\top} \boldsymbol{U}  \right) -\operatorname{tr}\left(\Lambda^{\top}\left(\boldsymbol{U}^{\top} \boldsymbol{U}-\boldsymbol{I}\right)\right) \<br>\mathbb{R}^{d \times p} \ni \frac{\partial \mathcal{L}}{\partial \boldsymbol{U}}=2 \breve{\boldsymbol{X}}\breve{\boldsymbol{X}}^{\top} \boldsymbol{U}-2 \boldsymbol{U} \Lambda \stackrel{\text { set }}{=} 0 \\Longrightarrow \breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top} \boldsymbol{U}=\boldsymbol{U} \Lambda<br>$$</p><h3 id="2-最小化重构Error"><a href="#2-最小化重构Error" class="headerlink" title="2 最小化重构Error"></a>2 最小化重构Error</h3><p>根据最近重构性，我们希望重构后的原数据会尽量相似，那就指出了我们的优化目标：<strong>最小化重构/还原Error(即距离)：</strong></p><p><strong>Reconstruction Distance</strong>：<br>$$<br>\left|\mathbf{X}-\mathbf{\hat{X}}\right|<em>{F}^{2} = \left|\breve{\boldsymbol{X}}-\boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right|</em>{F}^{2} \<br>=\operatorname{tr}\left(\left(\breve{\boldsymbol{X}}-\boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right)^{\top}\left(\breve{\boldsymbol{X}}-\boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right)\right) \<br>=\operatorname{tr}\left(\left(\breve{\boldsymbol{X}}^{\top}-\breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top}\right)\left(\breve{\boldsymbol{X}}-\boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right)\right) \<br>=\operatorname{tr}(\breve{\boldsymbol{X}}^{\top} \breve{\boldsymbol{X}}-2 \breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}+\breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \underbrace{\boldsymbol{U}^{\top} \boldsymbol{U}}<em>{\boldsymbol{I}} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}) \<br>=\operatorname{tr}\left(\breve{\boldsymbol{X}}^{\top} \breve{\boldsymbol{X}}-\breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right) \<br>=\operatorname{tr}\left(\breve{\boldsymbol{X}}^{\top} \breve{\boldsymbol{X}}\right)-\operatorname{tr}\left(\breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right) \<br>=\operatorname{tr}\left(\breve{\boldsymbol{X}}^{\top} \breve{\boldsymbol{X}}\right)-\operatorname{tr}\left(\breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top}\right)<br>$$<br><strong>Minimization</strong>：<br>$$<br>\begin{aligned}<br>&amp;\underset{\boldsymbol{U}}{\operatorname{minimize}}\left|\breve{\boldsymbol{X}}-\boldsymbol{U} \boldsymbol{U}^{\top} \breve{\boldsymbol{X}}\right|</em>{F}^{2} \<br>&amp;\text { subject to } \boldsymbol{U}^{\top} \boldsymbol{U}=\boldsymbol{I} \<br>\end{aligned}<br>$$</p><p>$$<br>\mathcal{L}=\operatorname{tr}\left(\breve{\boldsymbol{X}}^{\top} \breve{\boldsymbol{X}}\right)-\operatorname{tr}\left(\breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top} \boldsymbol{U} \boldsymbol{U}^{\top}\right)-\operatorname{tr}\left(\Lambda^{\top}\left(\boldsymbol{U}^{\top} \boldsymbol{U}-\boldsymbol{I}\right)\right) \<br>\mathbb{R}^{d \times p} \ni \frac{\partial \mathcal{L}}{\partial \boldsymbol{U}}=2 \breve{\boldsymbol{X}}\breve{\boldsymbol{X}}^{\top} \boldsymbol{U}-2 \boldsymbol{U} \Lambda \stackrel{\text { set }}{=} 0 \<br>\Longrightarrow \breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top} \boldsymbol{U}=\boldsymbol{U} \Lambda<br>$$</p><blockquote><p><strong>注释</strong></p><p>对于带矩阵约束的优化问题，通过<a href="https://math.stackexchange.com/questions/1104376/how-to-set-up-lagrangian-optimization-with-matrix-constrains" target="_blank" rel="noopener">拉格朗日乘子</a>可以求解。</p><p>e.g. 对于$\text{max或min} f(X) \ s.t. Φ(X)=0$，其拉格朗日函数为$\mathcal L(X,\Lambda) = f(X)+tr(\Lambda^{\top}Φ(X))$，具体请查阅 [3]。</p></blockquote><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>上述两个方法最后得出的式子都是一个：$\breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top} \boldsymbol{U}=\boldsymbol{U} \Lambda$。</p><p>至此，我们只需要对$\breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top}$进行特征值分解$\breve{\boldsymbol{X}} \breve{\boldsymbol{X}}^{\top} =\boldsymbol{U} \Lambda\boldsymbol{U}^{\top}$，将求得的特征值$\Lambda$从小到大进行排序:$\lambda_1\ge\lambda_2\ge\cdots\ge\lambda_d$，然后取前$p$个特征值对应构成特征向量$\mathbf{U} = [u_1,\cdots,u_p]$，其中$u_k$为单位特征向量，便是我们最后得到的<strong>投影矩阵</strong>了。</p><p>一般如何选择需要降的维数$p$呢？</p><h3 id="Scree-plot-Ratio"><a href="#Scree-plot-Ratio" class="headerlink" title="Scree plot, Ratio"></a>Scree plot, Ratio</h3><p>$$<br>ratio = \frac{\lambda_j}{\sum^d_{k=1}\lambda_k}<br>$$</p><p><img src="/2021/04/21/rl-pca/scree_plot.png" alt="screeplot"></p><p>一般没有要求的话，我们会选择ratio的转折点(knee)的那一点作为我们最后选择的p。对重构阈值$t$有要求的话就：<br>$$<br>\frac{\sum^p_{k=1}\lambda_k}{\sum^d_{k=1}\lambda_k}\ge t<br>$$<br>这样就OK啦。</p><h2 id="Dual-PCA"><a href="#Dual-PCA" class="headerlink" title="Dual PCA"></a>Dual PCA</h2><p>如果我们不用特征值分解呢？而是使用 奇异值分解 SVD 呢？这时候就是Dual PCA。</p><h3 id="Why-Dual-PCA"><a href="#Why-Dual-PCA" class="headerlink" title="Why Dual PCA?"></a>Why Dual PCA?</h3><ol><li>在对于n&lt;&lt;d的计算时，对$ \boldsymbol{\breve{X}}^{\top}\boldsymbol{\breve{X}} $的特征值分解比对$\boldsymbol{\breve{X}} \boldsymbol{\breve{X}}^{\top} $的特征值分解要快很多（因为$\boldsymbol{\breve{X}}^{\top}\boldsymbol{\breve{X}} \in\mathbb{R}^{n\times n}$而$\boldsymbol{\breve{X}}\boldsymbol{\breve{X}}^{\top} \in\mathbb{R}^{p\times p}$。</li><li>对于Kernel PCA的形式上有帮助。（Kernel PCA在之后有时间会尝试补充）</li></ol><h3 id="奇异值分解-SVD-Review"><a href="#奇异值分解-SVD-Review" class="headerlink" title="奇异值分解 SVD Review"></a>奇异值分解 SVD Review</h3><p>奇异值分解的形式都一样：$\mathbf{A} = \mathbf{U\Sigma V}^\top,\mathbf{A}\in \mathbb{R}^{a\times b}$</p><p>SVD 本身也可以用于降维，当原数据有zero mean时其实就是PCA在用SVD了。</p><p>奇异值分解有两种：</p><h4 id="Complete-SVD"><a href="#Complete-SVD" class="headerlink" title="Complete SVD"></a>Complete SVD</h4><p>$\mathbf{U}\in\mathbb{R}^{a\times a},\mathbf{V}\in\mathbb{R}^{b\times b},\mathbf{\Sigma}\in\mathbb{R}^{a\times b}$</p><p>此时$\mathbf{U}$称为左奇异向量，$\mathbf{V}$称为右奇异向量，$\mathbf{\Sigma}$是一个矩形矩阵，其<strong>主对角线</strong>上的值都是奇异值。<br>$$<br>\boldsymbol{\Sigma}=\left[\begin{array}{ccc}<br>\sigma_{1} &amp; 0 &amp; 0 \<br>\vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 0 &amp; \sigma_{\beta} \<br>0 &amp; 0 &amp; 0 \<br>\vdots &amp; \vdots &amp; \vdots \<br>0 &amp; 0 &amp; 0<br>\end{array}\right] \text { and }\left[\begin{array}{cccccc}<br>\sigma_{1} &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \<br>\vdots &amp; \ddots &amp; \vdots &amp; 0 &amp; \cdots &amp; 0 \<br>0 &amp; 0 &amp; \sigma_{\alpha} &amp; 0 &amp; \cdots &amp; 0<br>\end{array}\right]<br>$$<br>其中奇异值数量是$min(a,b)$。</p><h4 id="Incomplete-SVD"><a href="#Incomplete-SVD" class="headerlink" title="Incomplete SVD"></a>Incomplete SVD</h4><p>$\mathbf{U}\in\mathbb{R}^{a\times k},\mathbf{V}\in\mathbb{R}^{b\times k},\mathbf{\Sigma}\in\mathbb{R}^{k\times k}$ where $k:=min(a,b)$</p><p>此时$\mathbf{U}$称为左奇异向量，$\mathbf{V}$称为右奇异向量，$\mathbf{\Sigma}$是一个方正矩阵，其<strong>主对角线</strong>上的值都是奇异值。<br>$$<br>\boldsymbol{\Sigma}=\left[\begin{array}{ccc}<br>\sigma_{1} &amp; 0 &amp; 0 \<br>\vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 0 &amp; \sigma_{k} \<br>\end{array}\right]<br>$$</p><h4 id="SVD的特点"><a href="#SVD的特点" class="headerlink" title="SVD的特点"></a>SVD的特点</h4><p>首先，无论是Complete还是Incomplete，其$\mathbf{U,V}$都<strong>满足正交</strong>，即：<br>$$<br>s.t. \ \boldsymbol{U}^{\top} \boldsymbol{U}=\boldsymbol{I}\<br>s.t. \ \boldsymbol{V}^{\top} \boldsymbol{V}=\boldsymbol{I}<br>$$<br>其中$\mathbf{U}$是的特征分解后的特征向量，而$\mathbf{V}$为的特征值分解后的特征向量，证明如下。<br>$$<br>\begin{aligned}<br>\boldsymbol{A} \boldsymbol{A}^{\top} &amp;=\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)^{\top}=\boldsymbol{U} \boldsymbol{\Sigma} \underbrace{\boldsymbol{V}^{\top} \boldsymbol{V}}_{\boldsymbol{I}} \boldsymbol{\Sigma} \boldsymbol{U}^{\top} \<br>&amp;=\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{\Sigma} \boldsymbol{U}^{\top}=\boldsymbol{U} \boldsymbol{\Sigma}^{2} \boldsymbol{U}^{\top}<br>\end{aligned}\</p><p>\begin{aligned}<br>\boldsymbol{A}^{\top} \boldsymbol{A} &amp;=\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)^{\top}\left(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}\right)=\boldsymbol{V} \boldsymbol{\Sigma} \underbrace{\boldsymbol{U}^{\top} \boldsymbol{U}}_{\boldsymbol{I}} \boldsymbol{\Sigma} \boldsymbol{V}^{\top} \<br>&amp;=\boldsymbol{V} \boldsymbol{\Sigma} \boldsymbol{\Sigma} \boldsymbol{V}^{\top}=\boldsymbol{V} \boldsymbol{\Sigma}^{2} \boldsymbol{V}^{\top}<br>\end{aligned}<br>$$</p><h3 id="在PCA中使用SVD"><a href="#在PCA中使用SVD" class="headerlink" title="在PCA中使用SVD"></a>在PCA中使用SVD</h3><p>在这里，我们使用Incomplete SVD来做完原来PCA所做的所有内容，但我们将$\mathbf{U}$全部转换为$\mathbf{V}$：</p><p>$\mathbf{\breve{X}} = \mathbf{U\Sigma V}^\top$, where $\mathbf{U}\in\mathbb{R}^{d\times p},\mathbf{V}\in\mathbb{R}^{n\times p},\mathbf{\Sigma}\in\mathbb{R}^{p\times p}$</p><h4 id="1-Projection"><a href="#1-Projection" class="headerlink" title="1.Projection"></a><strong>1.Projection</strong></h4><p>$$<br>\mathbf{\tilde{X}}=\mathbf{U}^\top\mathbf{\breve{X}} = \underbrace{\boldsymbol{U}^{\top} \boldsymbol{U}}_{\boldsymbol{I}}\mathbf{\Sigma V}^\top =\mathbf{\Sigma V}^\top<br>$$</p><h4 id="2-Recounstruction"><a href="#2-Recounstruction" class="headerlink" title="2.Recounstruction"></a>2.Recounstruction</h4><p>$$<br>\mathbf{\breve{X}}\mathbf{V} = \mathbf{U\Sigma}\underbrace{\boldsymbol{V}^{\top} \boldsymbol{V}}_{\boldsymbol{I}} =\mathbf{U\Sigma}\<br>\Longrightarrow \mathbf{U}=\mathbf{\breve{X}}\mathbf{V\Sigma}^{-1}\<br>\begin{aligned}<br>\mathbf{\hat{X}}&amp;=\mathbf{U}\mathbf{\tilde{X}}+\mu\&amp;=\mathbf{\breve{X}}\mathbf{V\Sigma}^{-1}\mathbf{\tilde{X}}+\mu\&amp;=\mathbf{\breve{X}}\mathbf{V\Sigma}^{-1}\mathbf{\Sigma V}^\top+\mu\<br>&amp;=\mathbf{\breve{X}}\mathbf{VV}^\top+\mu<br>\end{aligned}<br>$$</p><h4 id="3-Test-Set"><a href="#3-Test-Set" class="headerlink" title="3. Test Set"></a>3. Test Set</h4><p>$$<br>\begin{array}{l}<br>\boldsymbol{U}=\check{\boldsymbol{X}} \boldsymbol{V} \Sigma^{-1} \Longrightarrow \boldsymbol{U}^{\top}=\Sigma^{-\top} \boldsymbol{V}^{\top} \breve{\boldsymbol{X}}^{\top}=\Sigma^{-1} \boldsymbol{V}^{\top} \breve{\boldsymbol{X}}^{\top} \<br>\tilde{\boldsymbol{X}}<em>{t}=\boldsymbol{U}^{\top} \breve{\boldsymbol{X}}</em>{t}=\Sigma^{-1} \boldsymbol{V}^{\top} \breve{\boldsymbol{X}}^{\top} \breve{\boldsymbol{X}}_{t}<br>\end{array}<br>$$</p><p>$$<br>\begin{aligned}<br>\boldsymbol{U} \boldsymbol{U}^{\top} &amp;=\breve{\boldsymbol{X}} \boldsymbol{V} \boldsymbol{\Sigma}^{-1} \boldsymbol{\Sigma}^{-1} \boldsymbol{V}^{\top} \breve{\boldsymbol{X}} \ \widehat{\boldsymbol{X}}<em>{t}&amp;=\breve{\boldsymbol{X}} \boldsymbol{V} \boldsymbol{\Sigma}^{-2} \boldsymbol{V}^{\top} \breve{\boldsymbol{X}}^{\top}  \breve{\boldsymbol{X}}</em>{t}+\boldsymbol{\mu}_{x}<br>\end{aligned}<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊聊机器学习——学习、资源与前景</title>
      <link href="/2021/03/18/ml-talk/"/>
      <url>/2021/03/18/ml-talk/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>Hi，好久不见，这里是千歲世野。由于被各种琐事拖占，我已经很久没有在这里发过技术博客了，虽然偶尔我也会有记录学习过程或者做知识的积累，但是暂时大部分都还没有到能让我值得将他们分享的地步，这篇算是能发的地步，希望能帮助到大家。</p></blockquote><p>这次的文章将着重讨论一个近年来，计算机/互联网行业的热点——人工智能，又或者换个稍微专业一点的名字机器学习。这一篇文章主要是面向对机器学习有些许兴趣但基本没有接触过的人群，这篇文章以后也同样将作为我的一个机器学习知识总结的开场白。这篇内容主要包含：</p><ol><li>分享机器学习这一领域究竟在做什么；</li><li>对感兴趣的朋友分享资源；</li><li>从行业/知识体系/现状上给出由衷的建议。</li></ol><h1 id="机器学习是什么？"><a href="#机器学习是什么？" class="headerlink" title="机器学习是什么？"></a>机器学习是什么？</h1><p>在此之前，我们先看几个生活中能见到的例子。</p><p>简单任务：</p><p>垃圾邮件/欺诈检测/交通预测</p><p>推荐系统：</p><p>音乐/商品/广告</p><p>计算机视觉：</p><p>行人识别/deepfake换头/AI自动上色/风格转移：</p><p>声音语言：</p><p>随机写小说/Siri/伴奏分离/机器作曲</p><p>深入内容：</p><p>病患X射线检测肺炎(CheXNet)/DNA测序/蛋白质重构/网络安全/大数据分析…</p><p>看到这里，关于人工智能到底是什么，有没有一点头绪呢？是的，目前这一领域做的事情，就是让<strong>机器</strong>去做原本由人来做的事情，无论是多小的一件事情，所有这一切任务与“人”的概念都无法脱离。这些机器学习任务人可以做到吗？当然可以。分辨哪个是垃圾邮件，给朋友推荐朋友可能喜欢的歌这类事情，一般人来做的话还要更加准确。再换一个领域来说，目前来说，机器写的小说/歌/文字那是能看的吗？非要说成是艺术的话也过于意识流/无厘头了。完全都还无法达到业界的水准。那机器与人的差别是什么呢？为什么要让机器去学习呢？</p><p>AI的作画/deep dream</p><p>原因很简单。首先，与人相比，机器的运算速度要比人类高上无数倍，而这个差别，是无法鸿越的。人可能一辈子能精通一件事情已经算是极其成功的人生了，可是AlphaGo通过相比起来很短的对棋局的学习时间，便能碾压连续20多次夺得世界第一的围棋手柯洁。其次，在你休息娱乐的一天，放在一旁的GPU可能已经跑了上兆亿次的运算了。将一个同样流程，譬如分拣邮件/推荐商品做上无数次对于人类来说是巨大的劳动力耗费，而对机器来说不过是小事一桩，这样的可重复性也是机器的优势。</p><p>人工智能这一领域在过去，是饱受争议的。出现在科幻小说电影里对其描绘的天马行空的同时，业界却没有办法回应大众的期待，很多时候所谓人工智能算法的效果甚至不如穷举，以至于很长一段时间，或者从那之后，业内研究人员几乎不会以”人工智能“标榜自己正在做的事情，而且因为看不到前景也致使了许多研究人员转而去其他领域研究。</p><p>但如今，到了算力爆棚到币圈都爆火的时代，机器学习的很多过去只停留在理论层面的内容得以实现，机器学习才终于能成为一波热潮。那机器学习算法是怎么实现的呢？</p><p>在这个篇幅里想要解释好任何一个算法都可能不太足够，那我举一个最最简单的例子好了。</p><p>关键两点：数据/算法</p><p>举人的学习过程：我们在学习解一道数学题可能要做上好几次同类的题目，才能理解这类数学题的通用解法。在此通用解法就是机器学习中学到的算法，而做过的题目就是机器学习输入的数据。基本上每一个机器学习算法都是以这样的流程进行的。</p><p>但即使是发展到现在，我们也很少会说，机器学习就是”人工智能“，为什么呢？因为人工智能听起来过于牛逼了。我们能看到机器学习算法大多都只是在处理单一的任务，而根本没有达到如电影小说中与人为敌控制世界，又或者各界哲学家纸上谈书所诉说的“伦理问题”之类的程度（看了一看我做的人工智障，到现在还认猫为狗呢）。</p><p>猫-&gt;Dog</p><p>又或者你说，人工智能的定义就是让机器去解决平时由人来解决的事情的话，那我们用计算器处理1+1=2是不是也能说是人工智能呢？其实是可以的，但是语义上我们会觉得这种任务不够“智能”，说白了不够牛逼。所以一般我们用机器学习，来指代以数学方法为背景的处理相较于简单任务更加复杂的方法。深度学习也是同样的道理，下图很好的阐述了他们之间的关系：</p><p><img src="/2021/03/19/ml-talk/relation.jpg" alt="preview"></p><p>为了更好区分它们，业内人会更具体化一些，以“机器学习”来称呼自己在做的内容，很多时候看各种机器学习相关的论文就能看到了，例如什么”研究不同的在线学习森林算法在脑电信号异常检测上的作用“（随便编的，反正差不多就是这样，实际情况还要更加具体）。</p><p>总之我的观点是：当前是机器学习领域极速发展的元年！无论是数据量还是算力，无论网络上的学习资源还是社会趋势，都指向一件事情——现在就是最适合机器学习发展的时代。</p><p>那要怎么进入这一领域呢？</p><h1 id="如何学习机器学习？"><a href="#如何学习机器学习？" class="headerlink" title="如何学习机器学习？"></a>如何学习机器学习？</h1><p>学习方法：资料+推导+实践+比较</p><p><strong>英语</strong>：</p><p>虽然中文领域还是有那么几本不错的书，但暂时前沿知识都由英文文献占据，如果你阅读翻译的书籍还可能遭遇大量的翻译问题。而且如果你深入到这一领域的时候，你会接触到的内容很有可能全是英文…写的论文是英文，发表学术报告是英文，甚至还要经常跟学术界不同国籍的人们打交道。学好英文，绝对让你学习道路上顺畅很多。</p><p><strong>数学</strong>：</p><p>开始想要接触机器学习时，大家应该都会觉得数学内容很多公式很多，不学数学没法学下去。我认为不无道理，但千万不要等全部学完了再学（这样我们离目的太远，要花很长时间才得到效果），毕竟就重要的数学部分就有高数，线代，概论，凸优化等等，等你精通这些估计得花上不少时间，我完全建议有兴趣进入机器学习这一行的人，先一边学机器学习基础算法，如kNN，线回，逻辑回，SVM，NB等等，在学习过程中遇到的不会的数学的部分再去摸索，譬如各个算法用极大似然优化时你可能得要了解条件概率，贝叶斯定理，矩估计之类的概率统计知识；你从一维拓展到多维你要去了解矩阵相关的线代知识；你去优化这些算法时你也得把偏导阿，积分之类的找回来…这样子你既能慢慢学会机器学习的基础算法，也把数学有所补充。</p><p>资源建议：</p><ul><li>微积分：小提琴书（James Stewart《Calculus》</li><li>线代：<ul><li>3B1B</li><li>MIT 18.06 搭配 Gilbert Strang, Introduction to Linear Algebra</li></ul></li><li>概率统计<ul><li>STAT110 搭配 Introduction to Probability Joseph K. Blitzstein （译本：概率论导论）</li><li>同济小蓝书内容覆盖面不错，但是不够深入浅出</li></ul></li></ul><p><strong>编程</strong>：</p><p>机器学习领域里，编程绝对是非必须的。但一点点的编程能力能给你带来巨大的帮助。比如想要把刚学会的算法实现一下加深印象，或者把算法应用到真实场景里，又或者是实验所需…编程能力绝对都能带来巨大的帮助。无论用的是Python还是R还是Matlab还是C++，选一门语言去用就对了。网上的资料很多很多，但学一门语言的基本语法（对！只学语法！暂时不需要的东西不要去学）真的花不了多长时间，一周基本上都能搞定（搞不定的绝对不是能力问题，是方法错了）</p><p><strong>资源检索能力</strong>：</p><p>无论是做研究，还是学习，你需要寻找的资源可能成千上万，想做伸手党让别人完全告诉你要学什么要做好什么，哪些需要哪些不需要是基本不可能的。论文库/搜索引擎等等，这些都一定要好好的利用好，习惯于自给自足丰衣足食。</p><p><strong>机器学习</strong>：</p><p>机器学习有很多优秀的内容，但他们无一不能一本带过，各有重点各有好处，一个概念的理解很可能需要结合各个资料，在这里分享用过/口碑极好的资源</p><ul><li>周志华，西瓜书 + 南瓜书：西瓜书科普，南瓜书深入解释</li><li>Ian GoodFellow, Deep Learning花书：深度学习圣经</li><li>李航，统计学习方法（入门良好）：以统计学角度解释一些基础的机器学习算法</li><li>T. Hastie, The Elements of Statistical Learning：以频率学派角度阐述大多机器学习算法</li><li>Gareth J. ,Introduction to Statistical Learning with R（译本：统计学习导论:基于R应用）</li><li>Richard S. Sutton, Reinforcement Learning: An Introduction：强化学习圣经</li><li>Sebastian Raschka, Python Machine Learning(译本:Python深度学习)：Python的sklearn框架实践上手专用，省去了大量的理论学习</li><li>Aston Zhang, 李沐, Dive into deep learning (译本：动手学机器学习)</li><li>概率论与数理统计（没错，这本居然覆盖面超广，但是大学一般讲不到的数理统计却是很多机器学习的基础内容）</li><li>Bishop，PRML：模式识别的经典</li></ul><p>避雷：</p><ul><li>机器学习实战</li><li>Python神经网络编程（不是不好，是太过于基础了，没必要这样去学，高中生入门用）</li><li>Kevin P. Murphy, Machine Learning（内容覆盖面很广，但是解释的不太好，而且不少typo。）</li></ul><p>看课是好，但是不要浪费时间：</p><ul><li>CS229：很基础的内容但是很深入，覆盖面不广，部分知识如NN已过时</li><li>Ng -ML：非常基础，极度入门，但是不深入，初学者可以看看，但是上面的所有内容可能只是走马观花没法形成概念，更加相当于科普</li><li>Ng - NN：讲的不错，偏入门，建议上coursera看，有作业，无论是数学还是编码相关都浅尝辄止，作业量不多（也不难），必须自觉去学习才行</li><li>机器学习白板：讲的特别好，但是数学基础不够的同学可能会看的云里雾里不知所云，不建议立即入手，建议学够一阵子之后，在学习机器学习算法时不懂再去看用来补充，会醍醐灌顶</li><li>李宏毅的各种课程：内容极广，而且比较前沿，可以作为补充来学习</li></ul><p>极度不推荐购买那些<strong>纯敲代码</strong>的书！无论对方标榜自己是什么谷歌/美团等大厂专家，都不要买。那样学习没有用处，因为代码网上都有，一开始入门都是调库，如果是要买来提升自己理解，只建议上面的那几本(python机器学习，动手学深度学习）。</p><p>在校的学生一定要好好利用自己的图书馆…因为这些书确实都很贵很难在其他地方看到的。书再多不怕，放着随时用来参考，太多了用来垫桌角都没问题。</p><p>关于以上内容，我还必须说一点。他们的先后关系是存在的，例如如果你对机器学习的框架都没有自己的理解就去碰深度学习，又或者随机过程都没听过就去捣鼓强化学习…这样肯定是不行的，但难道要先把他们学完？先把英语这一门语言学好来再去学这些？又或者把数学内容都学起来再去学机器学习的内容？那首先你会不会先花上三五年都还没碰到机器学习先不说，就你在学习数学的理论的过程中也绝对会因为将数学理论变现的等待时间过长而逐渐放弃。</p><p>说到这里了可以看到机器学习这一领域内容繁多，且深度很大，不知道大家有没有被劝退呢？如果没有的话，那再看下去吧。</p><h1 id="机器学习相关建议"><a href="#机器学习相关建议" class="headerlink" title="机器学习相关建议"></a>机器学习相关建议</h1><p>说实话机器学习，对大多数人来说不太实际。ML可谓是任何行业的强心剂，是任何行业的reinforcement，但他并不是刚需，所以没有足够资本的公司/与人工智能无关的公司一般都不需要这方向的发展、也不需要这类的人才，而那些需要的大公司虽然工资超高，对你的要求也会超级高。</p><p>机器学习本身学习难度很大，学习曲线波折，分支极其多，中文的资料相对欠缺，就我个人已经有一定数学与英语基础的人来说，我入门就已经花了一年多。</p><p>以这一领域就业的人群，大部分还是在高校中继续进行研究的，每天在实验室度过，靠论文评职称，投入产出的路线也十分曲折。如果说是工业界就一般行业硕博起步，而且如果你没几篇顶会论文（其难度参照几篇顶会吧：GPT-3,fasterRCNN…），也没什么实践化成果的话，实在很难踏入这一行。</p><p>想做的出色，不但需要巨大的理论学习投入，还需要大量的创新/实践/实验…相比于任何传统行业，这都是一条异常辛苦的路线，所以建议，要想在这一行能干下去，需要极高的热情，足够的学习与思辨能力，同时对业界有足够的踏足理解。</p><p>这是一个差距极其明显的一门学科，做的好的人极少但特别的出色特别牛逼，而此外的人与外行基本没有什么区别。所以，如果你没有“以此就业”极强的向往，十分建议只是把机器学习当做一门乐器，一个兴趣爱好，偶尔了解一下，调库玩玩看看效果，使用别人做好的API融合到自己项目中，这样也能很好的利用其对自己有提升。</p><p>所以我的意见是：</p><ol><li>成年人了，不建议跟风，不要被一时的新鲜感带跑，明确自己能力/人生规划/收益预期；</li><li>更不要一头钻到这里面去，必须有一个明确的目标才行（做研究？做工业化？做什么方向？），不然很容易迷失自己，到头来有用的都没学到；</li><li>甚至我认为你可以去把它当做副业，成为你事业的增强剂吧。</li></ol><p>加油。祝一路顺风。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>机器学习 周志华</li><li>风格迁移：<a href="https://arxiv.org/abs/1703.07511" target="_blank" rel="noopener">https://arxiv.org/abs/1703.07511</a></li><li>style2paint：<a href="http://lllyasviel.github.io/SplitFilling/" target="_blank" rel="noopener">http://lllyasviel.github.io/SplitFilling/</a></li><li>彩云小梦：<a href="http://if.caiyunai.com/dream/" target="_blank" rel="noopener">http://if.caiyunai.com/dream/</a></li><li>Siri: <a href="https://machinelearning.apple.com/research/siri-voices" target="_blank" rel="noopener">https://machinelearning.apple.com/research/siri-voices</a></li><li>deep dream:<a href="https://github.com/google/deepdream" target="_blank" rel="noopener">https://github.com/google/deepdream</a></li><li>伴奏分离：<a href="https://www.lalal.ai/" target="_blank" rel="noopener">https://www.lalal.ai/</a></li><li>chaxnet:<a href="https://stanfordmlgroup.github.io/projects/chexnet/" target="_blank" rel="noopener">https://stanfordmlgroup.github.io/projects/chexnet/</a></li><li>WaveNet:<a href="https://magenta.tensorflow.org/nsynth-instrument" target="_blank" rel="noopener">https://magenta.tensorflow.org/nsynth-instrument</a></li><li>DNA测序：<a href="https://arxiv.org/abs/1802.00810" target="_blank" rel="noopener">https://arxiv.org/abs/1802.00810</a></li><li>FasterRCNN:<a href="https://papers.nips.cc/paper/2015/file/14bfa6bb14875e45bba028a21ed38046-Paper.pdf" target="_blank" rel="noopener">https://papers.nips.cc/paper/2015/file/14bfa6bb14875e45bba028a21ed38046-Paper.pdf</a></li><li>动手学深度学习在线阅读：<a href="https://zh.d2l.ai/" target="_blank" rel="noopener">https://zh.d2l.ai/</a></li><li>白板机器学习：<a href="https://space.bilibili.com/97068901" target="_blank" rel="noopener">https://space.bilibili.com/97068901</a></li><li>YOLOv4:<a href="https://arxiv.org/abs/2004.10934" target="_blank" rel="noopener">https://arxiv.org/abs/2004.10934</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer刷题总结</title>
      <link href="/2020/08/20/lcof/"/>
      <url>/2020/08/20/lcof/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>这篇文章用于记录《剑指Offer》刷题的总结，对不同类型题目分类，对题目会进行多个方法解题，并分析方法的难度（以星号表示）、时间复杂度等。刷题使用的是Leetcode，部分代码来源于讨论区：<a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/lcof/</a></p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><blockquote><p>输入：[2, 3, 1, 0, 2, 5, 3]<br>        输出：2 或 3<br>        限制：2 &lt;= n &lt;= 100000</p></blockquote><h4 id="哈希表法O-n-☆☆☆"><a href="#哈希表法O-n-☆☆☆" class="headerlink" title="哈希表法O(n)            ☆☆☆"></a>哈希表法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                <span class="token keyword">return</span> i            <span class="token keyword">else</span><span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span></code></pre><h4 id="排序法O-nlogn-☆"><a href="#排序法O-nlogn-☆" class="headerlink" title="排序法O(nlogn)            ☆"></a>排序法O(nlogn)            ☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        排序后出现连续的数字便为重复。        '''</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        pre <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>pre<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                pre <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span></code></pre><h4 id="观察题意法O-n-☆☆☆☆☆"><a href="#观察题意法O-n-☆☆☆☆☆" class="headerlink" title="观察题意法O(n)            ☆☆☆☆☆"></a>观察题意法O(n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        由题意可知，一个无重复且范围都在0~n-1的数组应该排序后对应位置就是对应的值，        一个个去比对然后对换能直接排好序，但其中若出现冲突说明重复。        '''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> none</code></pre><h3 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">从尾到头打印链表</a></h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><blockquote><p>输入：head = [1,3,2]<br>        输出：[2,3,1]</p></blockquote><h4 id="栈O-n-☆☆☆"><a href="#栈O-n-☆☆☆" class="headerlink" title="栈O(n)            ☆☆☆"></a>栈O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        lis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            lis<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">return</span> lis<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><h4 id="递归法O-n-☆☆☆☆"><a href="#递归法O-n-☆☆☆☆" class="headerlink" title="递归法O(n)            ☆☆☆☆"></a>递归法O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        lis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> head <span class="token operator">and</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            lis <span class="token operator">=</span> self<span class="token punctuation">.</span>reversePrint<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        <span class="token keyword">if</span> head<span class="token punctuation">:</span>            lis<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> lis</code></pre><h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18 删除链表的节点"></a>18 <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">删除链表的节点</a></h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p><blockquote><p>输入: head = [4,5,1,9], val = 5<br>        输出: [4,1,9]<br>        解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p></blockquote><h4 id="双指针法O-n-☆☆☆"><a href="#双指针法O-n-☆☆☆" class="headerlink" title="双指针法O(n)            ☆☆☆"></a>双指针法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next        node <span class="token operator">=</span> head        <span class="token comment" spellcheck="true"># 虽然只是单指针，思路仍然是双指针</span>        <span class="token keyword">while</span> node<span class="token punctuation">:</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>next <span class="token operator">and</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                <span class="token keyword">return</span> head            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head</code></pre><h4 id="递归法O-n-☆☆☆☆-1"><a href="#递归法O-n-☆☆☆☆-1" class="headerlink" title="递归法O(n)            ☆☆☆☆"></a>递归法O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next        head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token keyword">return</span> head</code></pre><h3 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22 链表中倒数第k个节点"></a>22 <a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">链表中倒数第k个节点</a></h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><blockquote><p>给定一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2<br>        返回链表： 4-&gt;5</p></blockquote><h4 id="递归回溯法O-n-☆☆☆"><a href="#递归回溯法O-n-☆☆☆" class="headerlink" title="递归回溯法O(n)            ☆☆☆"></a>递归回溯法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>            <span class="token keyword">if</span> head<span class="token punctuation">:</span>                level <span class="token operator">=</span> self<span class="token punctuation">.</span>getKthFromEnd<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> k<span class="token punctuation">)</span>                <span class="token keyword">if</span> type<span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token operator">==</span> int<span class="token punctuation">:</span>                    level <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> level                                <span class="token keyword">return</span> head <span class="token keyword">if</span> level <span class="token operator">==</span> k <span class="token keyword">else</span> level            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span></code></pre><h4 id="双指针法O-n-☆☆"><a href="#双指针法O-n-☆☆" class="headerlink" title="双指针法O(n)            ☆☆"></a>双指针法O(n)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        former指针总比latter指针多k格，那么遍历到最后latter就是n-k        '''</span>            former<span class="token punctuation">,</span>latter <span class="token operator">=</span> head<span class="token punctuation">,</span>head            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                former <span class="token operator">=</span> former<span class="token punctuation">.</span>next            <span class="token keyword">while</span> former<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                former <span class="token operator">=</span> former<span class="token punctuation">.</span>next                latter <span class="token operator">=</span> latter<span class="token punctuation">.</span>next            <span class="token keyword">return</span> latter</code></pre><h4 id="存储法O-n-☆☆☆☆"><a href="#存储法O-n-☆☆☆☆" class="headerlink" title="存储法O(n)            ☆☆☆☆"></a>存储法O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        在三个方法里面算是最快        '''</span>        stack <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">)</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">return</span> stack<span class="token punctuation">[</span><span class="token operator">-</span>k<span class="token punctuation">]</span></code></pre><p>其中二次遍历法太简单，有点像暴力法就不详细讲了。</p><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">反转链表</a></h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>        输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>        限制：0 &lt;= 节点个数 &lt;= 5000</p></blockquote><h4 id="双指针法O-n-☆☆☆-1"><a href="#双指针法O-n-☆☆☆-1" class="headerlink" title="双指针法O(n)            ☆☆☆"></a>双指针法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        只需要一次遍历，保存一个换了方向的指针。        '''</span>        last <span class="token operator">=</span> None        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> last<span class="token punctuation">,</span> head <span class="token operator">=</span> last<span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next        <span class="token keyword">return</span> last</code></pre><h4 id="递归法O-n-☆☆☆☆☆"><a href="#递归法O-n-☆☆☆☆☆" class="headerlink" title="递归法O(n)            ☆☆☆☆☆"></a>递归法O(n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 尾节点保存</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head <span class="token operator">or</span> <span class="token operator">not</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># end只用于保留最后一个节点用于返回</span>        end <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 关键在head.next.next=head，让A->B转换为B->A</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head        head<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token keyword">return</span> end</code></pre><h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25 合并两个排序的链表"></a>25 <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">合并两个排序的链表</a></h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>        输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>        限制：0 &lt;= 节点个数 &lt;= 5000</p></blockquote><h4 id="双指针法O-m-n-☆☆"><a href="#双指针法O-m-n-☆☆" class="headerlink" title="双指针法O(m+n)            ☆☆"></a>双指针法O(m+n)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        head <span class="token operator">=</span> l <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> l1 <span class="token operator">and</span> l2<span class="token punctuation">:</span>            <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">></span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                l2<span class="token punctuation">,</span> l<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2            <span class="token keyword">else</span><span class="token punctuation">:</span>                l1<span class="token punctuation">,</span> l<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l1            l <span class="token operator">=</span> l<span class="token punctuation">.</span>next        l<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token keyword">if</span> l1 <span class="token keyword">else</span> l2        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next</code></pre><h4 id="递归法O-m-n-☆☆☆☆☆"><a href="#递归法O-m-n-☆☆☆☆☆" class="headerlink" title="递归法O(m+n)            ☆☆☆☆☆"></a>递归法O(m+n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> l1 <span class="token operator">and</span> l2<span class="token punctuation">:</span>            <span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>l2<span class="token punctuation">,</span> l1<span class="token punctuation">)</span> <span class="token keyword">if</span> l2<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l1<span class="token punctuation">.</span>val <span class="token keyword">else</span> <span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span>        <span class="token keyword">return</span> l1 <span class="token operator">or</span> l2</code></pre><h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">复杂链表的复制</a></h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><blockquote><p>输入：head = [[3,null],[3,0],[3,null]]<br>        输出：[[3,null],[3,0],[3,null]]</p></blockquote><h4 id="可以用一行代码解决（深复制原理，但没必要）"><a href="#可以用一行代码解决（深复制原理，但没必要）" class="headerlink" title="可以用一行代码解决（深复制原理，但没必要）"></a>可以用一行代码解决（深复制原理，但没必要）</h4><pre class=" language-python"><code class="language-python">copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>head<span class="token punctuation">)</span></code></pre><h4 id="哈希法O-n-☆☆☆"><a href="#哈希法O-n-☆☆☆" class="headerlink" title="哈希法O(n)            ☆☆☆"></a>哈希法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 以对象作键保存哈希表</span>        visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span> <span class="token keyword">return</span> None            <span class="token keyword">if</span> head <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                <span class="token keyword">return</span> visited<span class="token punctuation">[</span>head<span class="token punctuation">]</span>            copy <span class="token operator">=</span> Node<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            visited<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> copy            copy<span class="token punctuation">.</span>next <span class="token operator">=</span> dfs<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            copy<span class="token punctuation">.</span>random <span class="token operator">=</span> dfs<span class="token punctuation">(</span>head<span class="token punctuation">.</span>random<span class="token punctuation">)</span>            <span class="token keyword">return</span> copy        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>head<span class="token punctuation">)</span></code></pre><h4 id="原地修改法O-n-☆☆☆☆☆-推荐，节省空间"><a href="#原地修改法O-n-☆☆☆☆☆-推荐，节省空间" class="headerlink" title="原地修改法O(n)            ☆☆☆☆☆(推荐，节省空间)"></a>原地修改法O(n)            ☆☆☆☆☆(推荐，节省空间)</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'Node'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># 首先1->2->3转变为1->1'->2->2'->3->3'</span>        node <span class="token operator">=</span> head        <span class="token keyword">while</span> node<span class="token punctuation">:</span>            copy <span class="token operator">=</span> Node<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            copy<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next            node<span class="token punctuation">.</span>next <span class="token operator">=</span> copy            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 再给复制节点添加random</span>        node <span class="token operator">=</span> head        <span class="token keyword">while</span> node<span class="token punctuation">:</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>random<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>random <span class="token operator">=</span> node<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 取消相同的链接，分为1->2->3与1'->2'->3'</span>        newHead<span class="token punctuation">,</span>node <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span>head        <span class="token keyword">while</span> node <span class="token operator">and</span> node<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> node<span class="token punctuation">.</span>next            node<span class="token punctuation">.</span>next <span class="token operator">=</span> tmp<span class="token punctuation">.</span>next            node <span class="token operator">=</span> tmp        <span class="token keyword">return</span> newHead</code></pre><h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52 两个链表的第一个公共节点"></a>52 <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h3><p>输入两个链表，找出它们的第一个公共节点。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p><h4 id="哈希法O-n²-☆"><a href="#哈希法O-n²-☆" class="headerlink" title="哈希法O(n²)            ☆"></a>哈希法O(n²)            ☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        lis <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span>        <span class="token keyword">while</span> headA <span class="token operator">or</span> headB<span class="token punctuation">:</span>                        <span class="token keyword">if</span> headA<span class="token punctuation">:</span>                <span class="token keyword">if</span> headA <span class="token keyword">in</span> lis<span class="token punctuation">:</span>                    <span class="token keyword">return</span> headA                lis<span class="token punctuation">.</span>append<span class="token punctuation">(</span>headA<span class="token punctuation">)</span>                headA <span class="token operator">=</span> headA<span class="token punctuation">.</span>next            <span class="token keyword">if</span> headB<span class="token punctuation">:</span>                <span class="token keyword">if</span> headB <span class="token keyword">in</span> lis<span class="token punctuation">:</span>                    <span class="token keyword">return</span> headB                lis<span class="token punctuation">.</span>append<span class="token punctuation">(</span>headB<span class="token punctuation">)</span>                headB <span class="token operator">=</span> headB<span class="token punctuation">.</span>next        <span class="token keyword">return</span> None</code></pre><h4 id="双指针法O-m-n-c-☆☆☆☆☆"><a href="#双指针法O-m-n-c-☆☆☆☆☆" class="headerlink" title="双指针法O(m+n+c)            ☆☆☆☆☆"></a>双指针法O(m+n+c)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 这个方法非常巧妙:</span>        <span class="token comment" spellcheck="true"># 一个链表遍历完了开始遍历另一个链表，那么最多遍历两个链表的和的量，此时为无公共节点情况；</span>        <span class="token comment" spellcheck="true"># 而如果有公共节点就会在公共节点停止遍历，因为两人都遍历了双方不共通的部分与一次共通的部分。</span>        nodeA<span class="token punctuation">,</span> nodeB <span class="token operator">=</span> headA<span class="token punctuation">,</span> headB        <span class="token keyword">while</span> nodeA <span class="token operator">!=</span> nodeB<span class="token punctuation">:</span>            nodeA <span class="token operator">=</span> nodeA<span class="token punctuation">.</span>next <span class="token keyword">if</span> nodeA <span class="token keyword">else</span> headB            nodeB <span class="token operator">=</span> nodeB<span class="token punctuation">.</span>next <span class="token keyword">if</span> nodeB <span class="token keyword">else</span> headA        <span class="token keyword">return</span> nodeB</code></pre><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09 用两个栈实现队列"></a>09 <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><blockquote><p>输入：</p><p>​    函数：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>​            参数：[[],[3],[],[]]</p><p>输出：[null,null,3,-1]</p></blockquote><p><img src="https://assets.leetcode-cn.com/solution-static/jianzhi_09/jianzhi_9.gif" alt="fig1"></p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true"># 用于入栈</span>        self<span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true"># 用于出队</span>    <span class="token keyword">def</span> <span class="token function">appendTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30 包含min函数的栈"></a>30 <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><blockquote><p>输入：</p><p>​    函数：[“MinStack”,”push”,”push”,”push”,”min”,”top”,”pop”,”min”]<br>​            参数：[[],[-2],[0],[-1],[],[],[],[]]</p><p>输出：[null,null,null,null,-2,-1,null,-2]</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true"># 用于正常装栈</span>        self<span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true"># 用于获得min值</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 关键在此，stack2装载的是递减的数据，最后进去的一定为最小值</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>stack2 <span class="token operator">or</span> x <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2 <span class="token operator">and</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> tmp<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1 <span class="token keyword">else</span> None    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2 <span class="token keyword">else</span> None</code></pre><h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31 栈的压入、弹出序列"></a>31 <a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">栈的压入、弹出序列</a></h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h4 id="模拟法O-n-☆☆☆☆"><a href="#模拟法O-n-☆☆☆☆" class="headerlink" title="模拟法O(n)            ☆☆☆☆"></a>模拟法O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pushed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> popped<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> pushed<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>            <span class="token keyword">while</span> stack <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> popped<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">not</span> stack</code></pre><h3 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58-1 翻转单词顺序"></a>58-1 <a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">翻转单词顺序</a></h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理，并去除多余空格。例如输入字符串”I    am  a student.     “，则输出”student. a am I”。</p><h4 id="钻空子-☆"><a href="#钻空子-☆" class="headerlink" title="钻空子            ☆"></a>钻空子            ☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="常规做法-☆☆"><a href="#常规做法-☆☆" class="headerlink" title="常规做法            ☆☆"></a>常规做法            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>       <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        string<span class="token punctuation">,</span>tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token string">" "</span><span class="token punctuation">:</span>                tmp <span class="token operator">=</span> i<span class="token operator">+</span>tmp            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> tmp<span class="token punctuation">:</span>                    string <span class="token operator">+=</span> tmp<span class="token operator">+</span><span class="token string">" "</span>                    tmp <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>string <span class="token operator">+</span> tmp<span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="59-1-滑动窗口的最大值"><a href="#59-1-滑动窗口的最大值" class="headerlink" title="59-1 滑动窗口的最大值"></a>59-1 <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></h3><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><blockquote><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p><p>输出: [3,3,5,5,6,7] </p><p>滑动窗口的位置         最大值</p><hr><p>[1  3  -1] -3  5  3  6  7      3<br>        1 [3  -1  -3] 5  3  6  7       3<br>        1  3 [-1  -3  5] 3  6  7       5<br>        1  3  -1 [-3  5  3] 6  7       5<br>        1  3  -1  -3 [5  3  6] 7       6<br>        1  3  -1  -3  5 [3  6  7]      7</p></blockquote><h4 id="单调队列法-O-n-☆☆☆☆-这里用的递增，也可以用递减做"><a href="#单调队列法-O-n-☆☆☆☆-这里用的递增，也可以用递减做" class="headerlink" title="单调队列法 O(n)            ☆☆☆☆(这里用的递增，也可以用递减做)"></a>单调队列法 O(n)            ☆☆☆☆(这里用的递增，也可以用递减做)</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums <span class="token operator">or</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        aux<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 初始化窗口</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> aux<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                aux<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>aux<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 窗口移动</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> aux<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                aux<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> aux<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 判定窗口是否加入新元素</span>                <span class="token keyword">if</span> aux<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    aux<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 窗口为空，重新入窗</span>                aux<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> aux<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                        aux<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>aux<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h4 id="妙法O-n-☆☆☆☆☆"><a href="#妙法O-n-☆☆☆☆☆" class="headerlink" title="妙法O(n)            ☆☆☆☆☆"></a>妙法O(n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">*</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums        <span class="token comment" spellcheck="true"># 初始化左右数组</span>        <span class="token comment" spellcheck="true"># left[i]：按分块从左到i最大值</span>        <span class="token comment" spellcheck="true"># right[j]：按分块从右到j最大值</span>        <span class="token comment" spellcheck="true"># 分块：将原数组分为k份</span>        <span class="token comment" spellcheck="true"># 那么res[i] = max(right[i],left[i+k-1])</span>        left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        right<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 获取左右数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">,</span> left<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            j <span class="token operator">=</span> n <span class="token operator">-</span> i <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>max<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token operator">+</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07 重建二叉树"></a>07 <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h4 id="递归法-☆☆☆"><a href="#递归法-☆☆☆" class="headerlink" title="递归法            ☆☆☆"></a>递归法            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> preorder<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><h4 id="递归法改良-☆☆☆☆☆"><a href="#递归法改良-☆☆☆☆☆" class="headerlink" title="递归法改良            ☆☆☆☆☆"></a>递归法改良            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>dic<span class="token punctuation">,</span> self<span class="token punctuation">.</span>po <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> preorder        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dic<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token comment" spellcheck="true"># 用字典保存index方便查找</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>inorder<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pre_root<span class="token punctuation">,</span> in_left<span class="token punctuation">,</span> in_right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> in_left <span class="token operator">></span> in_right<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token comment" spellcheck="true"># 终止条件：中序遍历为空</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>po<span class="token punctuation">[</span>pre_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 建立当前子树的根节点</span>        i <span class="token operator">=</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">[</span>self<span class="token punctuation">.</span>po<span class="token punctuation">[</span>pre_root<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 搜索根节点在中序遍历中的索引，从而可对根节点、左子树、右子树完成划分。</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>pre_root <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> in_left<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 开启左子树的下层递归</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>i <span class="token operator">-</span> in_left <span class="token operator">+</span> pre_root <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> in_right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 开启右子树的下层递归</span>        <span class="token keyword">return</span> root <span class="token comment" spellcheck="true"># 返回根节点，作为上层递归的左（右）子节点</span></code></pre><h4 id="迭代法-☆☆☆☆"><a href="#迭代法-☆☆☆☆" class="headerlink" title="迭代法            ☆☆☆☆"></a>迭代法            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> preorder<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>            preorderval <span class="token operator">=</span> preorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            node <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>val <span class="token operator">!=</span> inorder<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 每次比较栈顶元素和inorder[index]</span>                node<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorderval<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> stack <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">==</span> inorder<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 栈顶元素等于inorder[index],弹出；并且index += 1</span>                    node <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                    index <span class="token operator">+=</span> <span class="token number">1</span>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorderval<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26 树的子结构"></a>26 <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">树的子结构</a></h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><blockquote><p>输入：A = [3,4,5,1,2], B = [4,1]<br>        输出：true</p></blockquote><h4 id="递归-☆☆☆☆"><a href="#递归-☆☆☆☆" class="headerlink" title="递归            ☆☆☆☆"></a>递归            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> B<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 找到根节点相同的结构</span>            <span class="token keyword">if</span> <span class="token operator">not</span> B<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token operator">not</span> A <span class="token operator">or</span> A<span class="token punctuation">.</span>val <span class="token operator">!=</span> B<span class="token punctuation">.</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> recur<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span> B<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> recur<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span> B<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> bool<span class="token punctuation">(</span>A <span class="token operator">and</span> B<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>recur<span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>left<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>isSubStructure<span class="token punctuation">(</span>A<span class="token punctuation">.</span>right<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27 二叉树的镜像"></a>27 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">二叉树的镜像</a></h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><blockquote><p>输入：root = [4,2,7,1,3,6,9]<br>        输出：[4,7,2,9,6,3,1]</p></blockquote><p>[4,2,7,1,3,6,9]</p><p>镜像输出：</p><p>[4,7,2,9,6,3,1]</p><h4 id="递归O-n-☆☆☆☆"><a href="#递归O-n-☆☆☆☆" class="headerlink" title="递归O(n)            ☆☆☆☆"></a>递归O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        node <span class="token operator">=</span> root        <span class="token keyword">if</span> node<span class="token punctuation">:</span>            node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>mirrorTree<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><h4 id="辅助栈O-n-☆☆☆"><a href="#辅助栈O-n-☆☆☆" class="headerlink" title="辅助栈O(n)            ☆☆☆"></a>辅助栈O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>            <span class="token keyword">while</span> stack<span class="token punctuation">:</span>                node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>   stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left        <span class="token keyword">return</span> root</code></pre><h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">对称的二叉树</a></h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p><blockquote><p>输入：root = [1,2,2,3,4,4,3]<br>        输出：true</p></blockquote><h4 id="规律法-☆☆☆☆☆"><a href="#规律法-☆☆☆☆☆" class="headerlink" title="规律法            ☆☆☆☆☆"></a>规律法            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> L <span class="token operator">and</span> <span class="token operator">not</span> R<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token operator">not</span> L <span class="token operator">or</span> <span class="token operator">not</span> R <span class="token operator">or</span> L<span class="token punctuation">.</span>val <span class="token operator">!=</span> R<span class="token punctuation">.</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> recur<span class="token punctuation">(</span>L<span class="token punctuation">.</span>left<span class="token punctuation">,</span> R<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> recur<span class="token punctuation">(</span>L<span class="token punctuation">.</span>right<span class="token punctuation">,</span> R<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token boolean">True</span></code></pre><h3 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32-1 从上到下打印二叉树"></a>32-1 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">从上到下打印二叉树</a></h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><h4 id="BFSO-n-☆☆"><a href="#BFSO-n-☆☆" class="headerlink" title="BFSO(n)            ☆☆"></a>BFSO(n)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 用Deque可以快速popleft</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h3 id="32-2-从上到下打印二叉树-II"><a href="#32-2-从上到下打印二叉树-II" class="headerlink" title="32-2 从上到下打印二叉树 II"></a>32-2 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof" target="_blank" rel="noopener">从上到下打印二叉树 II</a></h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><h4 id="BFSO-n-☆☆☆"><a href="#BFSO-n-☆☆☆" class="headerlink" title="BFSO(n)            ☆☆☆"></a>BFSO(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h4 id="BFS递归O-n-☆☆☆☆"><a href="#BFS递归O-n-☆☆☆☆" class="headerlink" title="BFS递归O(n)            ☆☆☆☆"></a>BFS递归O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> level <span class="token operator">==</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            res<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h3 id="32-3-从上到下打印二叉树-III"><a href="#32-3-从上到下打印二叉树-III" class="headerlink" title="32-3 从上到下打印二叉树 III"></a>32-3 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">从上到下打印二叉树 III</a></h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h4 id="BFSO-n-☆☆☆-1"><a href="#BFSO-n-☆☆☆-1" class="headerlink" title="BFSO(n)            ☆☆☆"></a>BFSO(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        k <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>   queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            k <span class="token operator">+=</span> <span class="token number">1</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp <span class="token keyword">if</span> k<span class="token operator">%</span><span class="token number">2</span> <span class="token keyword">else</span> tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 就是比上面多了这么点</span>        <span class="token keyword">return</span> res</code></pre><h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34 二叉树中和为某一值的路径"></a>34 <a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><blockquote><p>给定如下二叉树，以及目标和 sum = 22，返回：[ [5,4,11,2],   [5,8,4,5] ]</p></blockquote><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>回溯法</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res<span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> tar<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            tar <span class="token operator">-=</span> root<span class="token punctuation">.</span>val            <span class="token keyword">if</span> tar <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span>            recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> tar<span class="token punctuation">)</span>            recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> tar<span class="token punctuation">)</span>            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        recur<span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h3 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37 序列化二叉树"></a>37 <a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">序列化二叉树</a></h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res<span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>None<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span> <span class="token keyword">return</span>        vals<span class="token punctuation">,</span> i <span class="token operator">=</span> data<span class="token punctuation">,</span> <span class="token number">1</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>vals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>int<span class="token punctuation">(</span>vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> root</code></pre><h3 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54 二叉搜索树的第k大节点"></a>54 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">二叉搜索树的第k大节点</a></h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h4 id="DFS逆向中序遍历O-n-☆☆☆☆"><a href="#DFS逆向中序遍历O-n-☆☆☆☆" class="headerlink" title="DFS逆向中序遍历O(n)            ☆☆☆☆"></a>DFS逆向中序遍历O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 因为BST中序遍历一定为递增序列，逆向中序遍历则为递减</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                 <span class="token keyword">return</span>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 右</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># 若已找到便停止深入寻找</span>                <span class="token keyword">return</span>            self<span class="token punctuation">.</span>k <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 中</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                 self<span class="token punctuation">.</span>res <span class="token operator">=</span> root<span class="token punctuation">.</span>val            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 左</span>        self<span class="token punctuation">.</span>k <span class="token operator">=</span> k        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res</code></pre><h4 id="还有更秀的写法-☆☆☆"><a href="#还有更秀的写法-☆☆☆" class="headerlink" title="还有更秀的写法            ☆☆☆"></a>还有更秀的写法            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span>k<span class="token punctuation">]</span></code></pre><h3 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55-1 二叉树的深度"></a>55-1 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">二叉树的深度</a></h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><h4 id="DFSO-n-☆☆☆☆"><a href="#DFSO-n-☆☆☆☆" class="headerlink" title="DFSO(n)            ☆☆☆☆"></a>DFSO(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># 优雅</span>        <span class="token keyword">return</span> <span class="token number">0</span></code></pre><h4 id="BFSO-n-☆☆☆-2"><a href="#BFSO-n-☆☆☆-2" class="headerlink" title="BFSO(n)            ☆☆☆"></a>BFSO(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        queue<span class="token punctuation">,</span> level <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">:</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            queue <span class="token operator">=</span> tmp            level <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> level</code></pre><h3 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55-2 平衡二叉树"></a>55-2 <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">平衡二叉树</a></h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h4 id="先序遍历-深度O-nlogn-☆☆"><a href="#先序遍历-深度O-nlogn-☆☆" class="headerlink" title="先序遍历+深度O(nlogn)            ☆☆"></a>先序遍历+深度O(nlogn)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> node<span class="token punctuation">:</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>getDepth<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>getDepth<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>isBalanced<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isBalanced<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 子树是否平衡</span>            <span class="token keyword">return</span> abs<span class="token punctuation">(</span>self<span class="token punctuation">.</span>getDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>getDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 自己是否平衡</span>        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h4 id="后序遍历-剪枝O-n-☆☆☆☆"><a href="#后序遍历-剪枝O-n-☆☆☆☆" class="headerlink" title="后序遍历 + 剪枝O(n)            ☆☆☆☆"></a>后序遍历 + 剪枝O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                 <span class="token keyword">return</span> <span class="token number">0</span>            left <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 左</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                 <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            right <span class="token operator">=</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 右</span>            <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                 <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> abs<span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># 若不平衡直接剪枝</span>        <span class="token keyword">return</span> recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><h3 id="68-1-二叉搜索树的最近公共祖先"><a href="#68-1-二叉搜索树的最近公共祖先" class="headerlink" title="68-1 二叉搜索树的最近公共祖先"></a>68-1 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><blockquote><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>        输出: 6<br>        解释: 节点 2 和节点 8 的最近公共祖先是 6。</p></blockquote><p>分析：本题是一定存在最近祖先节点的，由于是二叉搜索树，只要p与q分别在当前节点异侧（或自身是其中一个节点），当前节点就一定是最近公共祖先。若他俩在同一侧，便深入到那一侧节点去继续搜。</p><h4 id="递归法O-n-☆☆☆"><a href="#递归法O-n-☆☆☆" class="headerlink" title="递归法O(n)            ☆☆☆"></a>递归法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><h4 id="迭代法O-n-☆☆☆"><a href="#迭代法O-n-☆☆☆" class="headerlink" title="迭代法O(n)            ☆☆☆"></a>迭代法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> root<span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val <span class="token operator">and</span> q<span class="token punctuation">.</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token keyword">break</span>        <span class="token keyword">return</span> root</code></pre><h3 id="68-2-二叉树的最近公共祖先"><a href="#68-2-二叉树的最近公共祖先" class="headerlink" title="68-2 二叉树的最近公共祖先"></a>68-2 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h4 id="积分法O-n-☆☆"><a href="#积分法O-n-☆☆" class="headerlink" title="积分法O(n)            ☆☆"></a>积分法O(n)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>            count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> <span class="token operator">not</span> node<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>val <span class="token operator">==</span> p<span class="token punctuation">.</span>val <span class="token operator">or</span> node<span class="token punctuation">.</span>val <span class="token operator">==</span>q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                count <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 每遇到一次p/q加一分</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                count <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res <span class="token operator">=</span> node        <span class="token comment" spellcheck="true"># 一旦积够两分，当前点就是最近公共祖先</span>                count <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">return</span> count        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res</code></pre><h4 id="递归法O-n-☆☆☆☆☆-1"><a href="#递归法O-n-☆☆☆☆☆-1" class="headerlink" title="递归法O(n)            ☆☆☆☆☆"></a>递归法O(n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 很优雅的递归</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root <span class="token operator">or</span> root <span class="token operator">==</span> p <span class="token operator">or</span> root <span class="token operator">==</span> q<span class="token punctuation">:</span> <span class="token keyword">return</span> root        left <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> left<span class="token punctuation">:</span> <span class="token keyword">return</span> right        <span class="token keyword">if</span> <span class="token operator">not</span> right<span class="token punctuation">:</span> <span class="token keyword">return</span> left        <span class="token keyword">return</span> root</code></pre><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">二维数组中的查找</a></h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>这题时间复杂度量级上区别不会太大，关键在于看从哪个角开始遍历，及时换行列就完事了。</p><h4 id="规律法-☆☆☆"><a href="#规律法-☆☆☆" class="headerlink" title="规律法            ☆☆☆"></a>规律法            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从左下角遍历最快</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span> i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span> j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h4 id="直接暴力-☆☆"><a href="#直接暴力-☆☆" class="headerlink" title="直接暴力            ☆☆"></a>直接暴力            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> matrix<span class="token punctuation">:</span>            <span class="token keyword">if</span> target <span class="token keyword">in</span> i<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h4 id="二分搜索-☆（这题并不必要）"><a href="#二分搜索-☆（这题并不必要）" class="headerlink" title="二分搜索            ☆（这题并不必要）"></a>二分搜索            ☆（这题并不必要）</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            m <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m<span class="token number">-1</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>                    mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>                    <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span>                        right <span class="token operator">=</span> mid<span class="token number">-1</span>                    <span class="token keyword">elif</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">True</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        left <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span>                left <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h3><h4 id="二分查找-O-logn-☆☆☆☆"><a href="#二分查找-O-logn-☆☆☆☆" class="headerlink" title="二分查找 O(logn)                ☆☆☆☆"></a>二分查找 O(logn)                ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        l<span class="token punctuation">,</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l<span class="token operator">!=</span>r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">></span>numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                l <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span>                    <span class="token comment" spellcheck="true"># 最小点在右半部分[m+1, r]</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">&lt;</span>numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m                    <span class="token comment" spellcheck="true"># 最小点在左半部分[l,m]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 相同时无法判断在哪，遂缩小范围，但不能缩l，因为m可能为l但不为r</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span></code></pre><h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39 数组中出现次数超过一半的数字"></a>39 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><h4 id="哈希-O-n-☆☆"><a href="#哈希-O-n-☆☆" class="headerlink" title="哈希 O(n)            ☆☆"></a>哈希 O(n)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> length<span class="token punctuation">:</span>                <span class="token keyword">return</span> i            dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span></code></pre><h4 id="摩尔投票法-O-n-☆☆☆☆"><a href="#摩尔投票法-O-n-☆☆☆☆" class="headerlink" title="摩尔投票法 O(n)            ☆☆☆☆"></a>摩尔投票法 O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        votes <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> votes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> x <span class="token operator">=</span> num            votes <span class="token operator">+=</span> <span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">==</span> x <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> x</code></pre><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50 第一个只出现一次的字符"></a>50 <a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">第一个只出现一次的字符</a></h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><blockquote><p>s = “abaccdeff”<br>        返回 “b”</p></blockquote><h4 id="哈希O-n-☆☆☆"><a href="#哈希O-n-☆☆☆" class="headerlink" title="哈希O(n)            ☆☆☆"></a>哈希O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">not</span> c <span class="token keyword">in</span> dic        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">return</span> c        <span class="token keyword">return</span> <span class="token string">' '</span></code></pre><h4 id="有序哈希O-n-☆☆☆☆"><a href="#有序哈希O-n-☆☆☆☆" class="headerlink" title="有序哈希O(n)            ☆☆☆☆"></a>有序哈希O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># python3.6后，字典默认有序，否则需用OrderedDict()</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">not</span> c <span class="token keyword">in</span> dic        <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> dic<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> v<span class="token punctuation">:</span> <span class="token keyword">return</span> k        <span class="token keyword">return</span> <span class="token string">' '</span></code></pre><h3 id="53-1-在排序数组中查找数字-I"><a href="#53-1-在排序数组中查找数字-I" class="headerlink" title="53-1 在排序数组中查找数字 I"></a>53-1 <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">在排序数组中查找数字 I</a></h3><p>统计一个数字在排序数组中出现的次数。</p><h4 id="二分查找-O-logn-☆☆"><a href="#二分查找-O-logn-☆☆" class="headerlink" title="二分查找 O(logn)            ☆☆"></a>二分查找 O(logn)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l<span class="token operator">&lt;=</span>r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token comment" spellcheck="true"># 二分找到target点</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">:</span>                l<span class="token operator">=</span>m<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">:</span>                r<span class="token operator">=</span>m<span class="token number">-1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                l <span class="token operator">=</span> m<span class="token number">-1</span>                <span class="token keyword">while</span> l<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># target往左找左边界</span>                    l<span class="token operator">-=</span><span class="token number">1</span>                r <span class="token operator">=</span> m <span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">while</span> r<span class="token operator">&lt;=</span>length <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># target往右找右边界</span>                    r<span class="token operator">+=</span><span class="token number">1</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> r<span class="token operator">-</span>l<span class="token number">-1</span> <span class="token keyword">if</span> l<span class="token operator">&lt;</span>r <span class="token keyword">else</span> <span class="token number">0</span>                        <span class="token comment" spellcheck="true"># 避免找不到的情况</span></code></pre><h4 id="二分查找·改-O-logn-☆☆☆☆"><a href="#二分查找·改-O-logn-☆☆☆☆" class="headerlink" title="二分查找·改 O(logn)            ☆☆☆☆"></a>二分查找·改 O(logn)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> <span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>tar<span class="token punctuation">)</span><span class="token punctuation">:</span>            i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> j<span class="token punctuation">:</span>                m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tar<span class="token punctuation">:</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 修改条件，直接找右边界</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">return</span> i        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">-</span> helper<span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 两次二分完成</span></code></pre><h3 id="53-2-0～n-1中缺失的数字"><a href="#53-2-0～n-1中缺失的数字" class="headerlink" title="53-2  0～n-1中缺失的数字"></a>53-2 <a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener"> 0～n-1中缺失的数字</a></h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h4 id="二分查找O-logn-☆☆"><a href="#二分查找O-logn-☆☆" class="headerlink" title="二分查找O(logn)            ☆☆"></a>二分查找O(logn)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> j<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> m<span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># 想到这个条件就完事了</span>                i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                 j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> i</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21 调整数组顺序使奇数位于偶数前面"></a>21 <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h4 id="双指针法-O-n"><a href="#双指针法-O-n" class="headerlink" title="双指针法 O(n)"></a>双指针法 O(n)</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 操作十分像快速排序</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> j <span class="token operator">-=</span> <span class="token number">1</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> nums</code></pre><h3 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40 最小的k个数"></a>40 <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></h3><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><blockquote><p>输入：arr = [3,2,1], k = 2<br>        输出：[1,2] 或者 [2,1]</p></blockquote><p>大可以sort()了之后选前几个切片，但是没必要。</p><h4 id="左半快排-O-n-☆☆☆☆"><a href="#左半快排-O-n-☆☆☆☆" class="headerlink" title="左半快排 O(n)            ☆☆☆☆"></a>左半快排 O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>        pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        i <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">randomized_partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>        nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">randomized_selected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        pos <span class="token operator">=</span> self<span class="token punctuation">.</span>randomized_partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>        num <span class="token operator">=</span> pos <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> k <span class="token operator">&lt;</span> num<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>randomized_selected<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">elif</span> k <span class="token operator">></span> num<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>randomized_selected<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> k <span class="token operator">-</span> num<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>randomized_selected<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span></code></pre><h4 id="哈希-计数排序-O-M-对本题是最快的，但有局限性（因为范围给定了，不大且是整数）"><a href="#哈希-计数排序-O-M-对本题是最快的，但有局限性（因为范围给定了，不大且是整数）" class="headerlink" title="哈希/计数排序 O(M)            对本题是最快的，但有局限性（因为范围给定了，不大且是整数）"></a>哈希/计数排序 O(M)            对本题是最快的，但有局限性<em>（因为范围给定了，不大且是整数）</em></h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10000</span>        res<span class="token punctuation">,</span>idx <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">while</span> k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>idx<span class="token punctuation">)</span>                k <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                idx <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><h4 id="堆排序-O-nlogn-☆☆☆☆☆"><a href="#堆排序-O-nlogn-☆☆☆☆☆" class="headerlink" title="堆排序 O(nlogn)            ☆☆☆☆☆"></a>堆排序 O(nlogn)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Python中默认堆为小根堆，需要加上负号作为大根堆使用</span>        hp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>hp<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">-</span>hp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>hp<span class="token punctuation">)</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>hp<span class="token punctuation">,</span> <span class="token operator">-</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> hp<span class="token punctuation">]</span>        <span class="token keyword">return</span> res</code></pre><h3 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45 把数组排成最小的数"></a>45 <a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><h4 id="找规律-O-nlogn-☆☆☆☆"><a href="#找规律-O-nlogn-☆☆☆☆" class="headerlink" title="找规律 O(nlogn)            ☆☆☆☆"></a>找规律 O(nlogn)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">sort_rule</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            a<span class="token punctuation">,</span> b <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">,</span> y <span class="token operator">+</span> x            <span class="token keyword">if</span> a <span class="token operator">></span> b<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>            <span class="token keyword">elif</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        strs <span class="token operator">=</span> <span class="token punctuation">[</span>str<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        strs<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key <span class="token operator">=</span> functools<span class="token punctuation">.</span>cmp_to_key<span class="token punctuation">(</span>sort_rule<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>strs<span class="token punctuation">)</span></code></pre><h3 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57 和为s的两个数字"></a>57 <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">和为s的两个数字</a></h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h4 id="双指针-O-n-☆☆☆"><a href="#双指针-O-n-☆☆☆" class="headerlink" title="双指针 O(n)            ☆☆☆"></a>双指针 O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        l<span class="token punctuation">,</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        s <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">while</span> s<span class="token operator">!=</span>target <span class="token operator">and</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token operator">></span>target<span class="token punctuation">:</span>                r<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l<span class="token operator">+=</span><span class="token number">1</span>            s <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12 矩阵中的路径"></a>12 <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>        [“s”,”f”,”c”,”s”],<br>        [“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h4 id="DFS-O-3ᵏMN-☆☆☆"><a href="#DFS-O-3ᵏMN-☆☆☆" class="headerlink" title="DFS O(3ᵏMN)            ☆☆☆"></a>DFS O(3ᵏMN)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>length <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> x<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> x<span class="token operator">></span>row <span class="token operator">or</span> y<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">or</span> y<span class="token operator">></span>col <span class="token operator">or</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> word<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> <span class="token operator">not</span> k<span class="token operator">-</span>length<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                 <span class="token comment" spellcheck="true"># 标记</span>            <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> dfs<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token number">-1</span><span class="token punctuation">,</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> word<span class="token punctuation">[</span>k<span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># 还原</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13 机器人的运动范围"></a>13 <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">机器人的运动范围</a></h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>这题的两个重点：</p><ul><li>判断其不需要左和上的移动便可以遍历全部</li><li>数位和小于k的判断：s_x + 1 if (x + 1) % 10 else s_x - 8</li></ul><h4 id="DFS-O-MN-☆☆☆☆☆"><a href="#DFS-O-MN-☆☆☆☆☆" class="headerlink" title="DFS O(MN)            ☆☆☆☆☆"></a>DFS O(MN)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> si<span class="token punctuation">,</span> sj<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> m <span class="token operator">or</span> j <span class="token operator">>=</span> n <span class="token operator">or</span> k <span class="token operator">&lt;</span> si <span class="token operator">+</span> sj <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> dfs<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> si <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token keyword">else</span> si <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">,</span> sj<span class="token punctuation">)</span> <span class="token operator">+</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> si<span class="token punctuation">,</span> sj <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token keyword">else</span> sj <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span>        visited <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><h4 id="BFS-O-MN-☆☆☆☆"><a href="#BFS-O-MN-☆☆☆☆" class="headerlink" title="BFS O(MN)            ☆☆☆☆"></a>BFS O(MN)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        queue<span class="token punctuation">,</span> visited<span class="token punctuation">,</span>  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> si<span class="token punctuation">,</span> sj <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> m <span class="token operator">or</span> j <span class="token operator">>=</span> n <span class="token operator">or</span> k <span class="token operator">&lt;</span> si <span class="token operator">+</span> sj <span class="token operator">or</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span> <span class="token keyword">continue</span>            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> si <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token keyword">else</span> si <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">,</span> sj<span class="token punctuation">)</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> si<span class="token punctuation">,</span> sj <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token keyword">else</span> sj <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>visited<span class="token punctuation">)</span></code></pre><h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><h4 id="DFS-O-n-☆☆☆☆"><a href="#DFS-O-n-☆☆☆☆" class="headerlink" title="DFS O(n!)            ☆☆☆☆"></a>DFS O(n!)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        res<span class="token punctuation">,</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>lis<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>lis<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 访问到最后一个字符，直接添加到答案</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>string<span class="token operator">+</span>lis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            count <span class="token operator">=</span> <span class="token number">0</span>            visited <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 保存当前字符出现过的字符</span>            <span class="token keyword">while</span> count <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>lis<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 每个字符都访问过了就结束</span>                count<span class="token operator">+=</span><span class="token number">1</span>                    <span class="token comment" spellcheck="true"># 用计数来循环是为了方便直接popleft，取剩余的queue继续使用</span>                tmp <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 每次取第一个进行函数，剩下的为后续可能的字符</span>                <span class="token keyword">if</span> tmp <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 在第N个字符出现过同样的字符，则直接剪枝</span>                    dfs<span class="token punctuation">(</span>queue<span class="token punctuation">,</span>string<span class="token operator">+</span>tmp<span class="token punctuation">)</span>                visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 将取出的字符还回去</span>        dfs<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><blockquote><p>输入：00000000000000000000000000001011<br>        输出：3</p></blockquote><h4 id="移位-O-n-☆☆☆"><a href="#移位-O-n-☆☆☆" class="headerlink" title="移位 O(n)            ☆☆☆"></a>移位 O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span><span class="token number">1</span>            n<span class="token operator">>></span><span class="token operator">=</span><span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><h4 id="消1法-O-m-☆☆☆☆☆"><a href="#消1法-O-m-☆☆☆☆☆" class="headerlink" title="消1法 O(m)            ☆☆☆☆☆"></a>消1法 O(m)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> n<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>            n <span class="token operator">&amp;</span><span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 最右侧的1替换为0</span>        <span class="token keyword">return</span> res</code></pre><h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">数值的整数次方</a></h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><h4 id="快速幂-O-logn-☆☆☆☆☆"><a href="#快速幂-O-logn-☆☆☆☆☆" class="headerlink" title="快速幂 O(logn)            ☆☆☆☆☆"></a>快速幂 O(logn)            ☆☆☆☆☆</h4><p>将指数n转换成n=1+2+4+…+2ᵐ-1，二进制处理，再利用指数相加即幂相乘得到快速幂。</p><p>如 <strong>7-&gt;111</strong>，则有 <strong>x⁷ = x¹ · x² · x⁴</strong>，<strong>10-&gt;1010</strong>，则有<strong>x¹⁰ = <del>x¹</del> · x² · <del>x⁴</del> · x⁸</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myPow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> float<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">,</span> <span class="token operator">-</span>n        <span class="token keyword">while</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span> res <span class="token operator">*=</span> x        <span class="token comment" spellcheck="true"># 有余对应二进制位为1，即此要参与相乘</span>            x <span class="token operator">*=</span> x                    <span class="token comment" spellcheck="true"># 为下一位的相乘做准备</span>            n <span class="token operator">>></span><span class="token operator">=</span> <span class="token number">1</span>                    <span class="token comment" spellcheck="true"># n//2</span>        <span class="token keyword">return</span> res</code></pre><h3 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1 数组中数字出现的次数"></a>56-1 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数</a></h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h4 id="分组异或-O-n-☆☆☆☆☆"><a href="#分组异或-O-n-☆☆☆☆☆" class="headerlink" title="分组异或 O(n)            ☆☆☆☆☆"></a>分组异或 O(n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        ret <span class="token operator">=</span> functools<span class="token punctuation">.</span>reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span>x <span class="token operator">^</span> y<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>        d <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> d <span class="token operator">&amp;</span> ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            d <span class="token operator">&lt;&lt;</span><span class="token operator">=</span> <span class="token number">1</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> d<span class="token punctuation">:</span>                a <span class="token operator">^</span><span class="token operator">=</span> i            <span class="token keyword">else</span><span class="token punctuation">:</span>                b <span class="token operator">^</span><span class="token operator">=</span> i        <span class="token keyword">return</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span></code></pre><h3 id="56-2-数组中数字出现的次数-II"><a href="#56-2-数组中数字出现的次数-II" class="headerlink" title="56-2 数组中数字出现的次数 II"></a>56-2 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">数组中数字出现的次数 II</a></h3><p>一个整型数组 <code>nums</code> 里除一个数字之外，其他数字都出现了三次。请写程序找出这个只出现一次的数字。</p><h3 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64 求1+2+…+n"></a>64 <a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">求1+2+…+n</a></h3><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</p><h4 id="钻空子-没必要"><a href="#钻空子-没必要" class="headerlink" title="钻空子            (没必要)"></a>钻空子            (没必要)</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> sum<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="递归法O-n-☆☆☆-1"><a href="#递归法O-n-☆☆☆-1" class="headerlink" title="递归法O(n)            ☆☆☆"></a>递归法O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumNums</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> n <span class="token operator">and</span> <span class="token punctuation">(</span>n<span class="token operator">+</span>self<span class="token punctuation">.</span>sumNums<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># python返回特性，多个True返回最后一个值</span></code></pre><h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 <a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><h4 id="钻空子-（没必要）"><a href="#钻空子-（没必要）" class="headerlink" title="钻空子            （没必要）"></a>钻空子            （没必要）</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1 斐波那契数列"></a>10-1 <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">斐波那契数列</a></h3><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。答案需要取模 1e9+7。(0&lt;=n&lt;=100)</p><p>可以用打表法做，但是没必要。</p><h4 id="定义法-动态规划O-n-☆☆☆☆☆"><a href="#定义法-动态规划O-n-☆☆☆☆☆" class="headerlink" title="定义法/动态规划O(n)            ☆☆☆☆☆"></a>定义法/动态规划O(n)            ☆☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>        f1<span class="token punctuation">,</span>f2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>        <span class="token keyword">while</span> n<span class="token number">-1</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            ans <span class="token operator">=</span> f1 <span class="token operator">+</span> f2            ans <span class="token operator">-=</span> <span class="token number">0</span> <span class="token keyword">if</span> ans <span class="token operator">&lt;</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span> <span class="token keyword">else</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span>    <span class="token comment" spellcheck="true"># 由于范围小可以直接减省去了求余运算</span>            ans <span class="token operator">=</span> int<span class="token punctuation">(</span>ans<span class="token punctuation">)</span>            f1 <span class="token operator">=</span> f2            f2 <span class="token operator">=</span> ans            n<span class="token operator">-=</span><span class="token number">1</span>        <span class="token keyword">return</span> f2</code></pre><h4 id="递归法O-n-☆☆☆-其实就是递归写动态规划，也可以加记忆化"><a href="#递归法O-n-☆☆☆-其实就是递归写动态规划，也可以加记忆化" class="headerlink" title="递归法O(n)            ☆☆☆(其实就是递归写动态规划，也可以加记忆化)"></a>递归法O(n)            ☆☆☆(其实就是递归写动态规划，也可以加记忆化)</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    @lru_cache<span class="token punctuation">(</span>None<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 用于定义递归的深度为无限</span>    <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> n        <span class="token keyword">return</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1000000007</span></code></pre><h3 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2 青蛙跳台阶问题"></a>10-2 <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。答案需要取模 1e9+7。(0&lt;=n&lt;=100)</p><p>由于此题一样是有$f(n)=f(n-1)+f(n-2)$，上述的动态规划法基本改改初始值搬下来就能用就不重复写了。</p><h4 id="递归法O-n-☆☆☆-2"><a href="#递归法O-n-☆☆☆-2" class="headerlink" title="递归法O(n)            ☆☆☆"></a>递归法O(n)            ☆☆☆</h4><pre><code>class Solution:    @lru_cache(None)    # 用于定义递归的深度为无限    def numWays(self, n: int) -&gt; int:        if n &lt;= 1:            return 1        if n == 2:            return 2        return int((self.numWays(n-1) + self.numWays(n-2))% (1e9+7))</code></pre><h4 id="记忆化递归法O-n-☆☆☆☆"><a href="#记忆化递归法O-n-☆☆☆☆" class="headerlink" title="记忆化递归法O(n)            ☆☆☆☆"></a>记忆化递归法O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    @lru_cache<span class="token punctuation">(</span>None<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 用于定义递归的深度为无限</span>    <span class="token keyword">def</span> <span class="token function">numWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span>  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">98</span>        <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span>            f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> dp<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">0</span> <span class="token keyword">if</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> int<span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">(</span>n<span class="token punctuation">)</span></code></pre><h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">正则表达式匹配</a></h3><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h4 id="回溯法-O-n-m-2-frac-n-m-2-☆☆☆☆"><a href="#回溯法-O-n-m-2-frac-n-m-2-☆☆☆☆" class="headerlink" title="回溯法 $O((n+m)*2^\frac{n+m}{2})$    ☆☆☆☆"></a>回溯法 $O((n+m)*2^\frac{n+m}{2})$    ☆☆☆☆</h4><ul><li>当主串与*匹配0次时，删除包括该*前的匹配串</li><li>当主串需要与*匹配多次时，减一次</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s        first_match <span class="token operator">=</span> bool<span class="token punctuation">(</span>s <span class="token operator">and</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 第一个字母是否匹配</span>        <span class="token comment" spellcheck="true"># 如果 p 第二个字母是 *</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># *号效果0次 or *号效果大于0次，让主串减去一次让主串</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="动态规划-O-mn-☆☆☆☆☆"><a href="#动态规划-O-mn-☆☆☆☆☆" class="headerlink" title="动态规划 O(mn)            ☆☆☆☆☆"></a>动态规划 O(mn)            ☆☆☆☆☆</h4><p>$d p(i)(j)=\left{\begin{array}{ll}<br>d p(i-1)(j-1), &amp; \mathrm{s}(\mathrm{i})=\mathrm{p}(\mathrm{j}) \text { or } \mathrm{p}(\mathrm{j})= “.”\<br>d p(i)(j-2), &amp; \mathrm{p}(\mathrm{j})=<em>, \mathrm{p}(\mathrm{j}-1) !=\mathrm{s}(\mathrm{i}) \<br>d p(i-1)(j) \operatorname {or} dp(i)(j-2), &amp; \mathrm{p}(\mathrm{j})=</em>, \mathrm{p}(\mathrm{j}-1)=\mathrm{s}(\mathrm{i}) \text { or } \mathrm{p}(\mathrm{j}-1)=”.” \<br>\text {False} , &amp; \text {else}<br>\end{array}\right.$</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s        m<span class="token punctuation">,</span>n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 初始化当s为空的dp数组(dp[i][j] = s[:i]是否匹配p[:i])</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span>      <span class="token comment" spellcheck="true"># 每有一个*，该dp值会与其前第二个一样</span>        <span class="token comment" spellcheck="true"># 动态规划</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> p<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> p<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> p<span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span>                   <span class="token comment" spellcheck="true"># 匹配0次</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 匹配0次 or 匹配多次</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span></code></pre><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><h4 id="动态规划-O-n-☆☆☆☆"><a href="#动态规划-O-n-☆☆☆☆" class="headerlink" title="动态规划 O(n)            ☆☆☆☆"></a>动态规划 O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span>  <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span></code></pre><h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 <a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">丑数</a></h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><h4 id="动态规划-O-n-☆☆☆☆-1"><a href="#动态规划-O-n-☆☆☆☆-1" class="headerlink" title="动态规划 O(n)            ☆☆☆☆"></a>动态规划 O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token punctuation">:</span>        dp<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            n2<span class="token punctuation">,</span> n3<span class="token punctuation">,</span> n5 <span class="token operator">=</span> dp<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">5</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>n2<span class="token punctuation">,</span> n3<span class="token punctuation">,</span> n5<span class="token punctuation">)</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> n2<span class="token punctuation">:</span> a <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> n3<span class="token punctuation">:</span> b <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> n5<span class="token punctuation">:</span> c <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span></code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43 1～n整数中1出现的次数"></a>43 <a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1～n整数中1出现的次数</a></h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><h4 id="递归-O-lgn-☆☆☆☆☆"><a href="#递归-O-lgn-☆☆☆☆☆" class="headerlink" title="递归 O(lgn)            ☆☆☆☆☆"></a>递归 O(lgn)            ☆☆☆☆☆</h4><p>解析参考<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/python-olgn-di-gui-fang-fa-qing-xi-jiang-jie-by-ch/" target="_blank" rel="noopener">这里</a>。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 剩余位为0</span>            n <span class="token operator">=</span> len<span class="token punctuation">(</span>str<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 长度，即最高位数</span>            <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>                    strs <span class="token operator">=</span> str<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            s0 <span class="token operator">=</span> int<span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> s0 <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> s0 <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">**</span> <span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span> <span class="token operator">+</span> helper<span class="token punctuation">(</span>int<span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token operator">**</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> s0 <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">**</span> <span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span> <span class="token operator">+</span> helper<span class="token punctuation">(</span>int<span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>int<span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>n<span class="token punctuation">)</span></code></pre><h3 id="57-2-和为s的连续正数序列"><a href="#57-2-和为s的连续正数序列" class="headerlink" title="57-2 和为s的连续正数序列"></a>57-2 <a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">和为s的连续正数序列</a></h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><blockquote><p>输入：target = 9<br>        输出：[[2,3,4],[4,5]]</p></blockquote><h4 id="滑动窗口法-O-n-☆☆☆"><a href="#滑动窗口法-O-n-☆☆☆" class="headerlink" title="滑动窗口法 O(n)            ☆☆☆"></a>滑动窗口法 O(n)            ☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 滑动窗口的左边界</span>    j <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 滑动窗口的右边界</span>    sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 滑动窗口中数字的和</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> target <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> sum <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 右边界向右移动</span>            sum <span class="token operator">+=</span> j            j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> sum <span class="token operator">></span> target<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 左边界向右移动</span>            sum <span class="token operator">-=</span> i            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 记录结果</span>            arr <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 左边界向右移动</span>            sum <span class="token operator">-=</span> i            i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> res</code></pre><h3 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58-2 左旋转字符串"></a>58-2 <a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">左旋转字符串</a></h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><h4 id="切片-☆"><a href="#切片-☆" class="headerlink" title="切片            ☆"></a>切片            ☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">return</span> s<span class="token punctuation">[</span>n<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span></code></pre><h4 id="拼接-☆☆"><a href="#拼接-☆☆" class="headerlink" title="拼接            ☆☆"></a>拼接            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseLeftWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> n <span class="token operator">+</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">%</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span></code></pre><h3 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 <a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><h4 id="模拟法-O-n²-☆☆"><a href="#模拟法-O-n²-☆☆" class="headerlink" title="模拟法 O(n²)            ☆☆"></a>模拟法 O(n²)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        lis <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                <span class="token comment" spellcheck="true"># 记录上一次删除的位置</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>lis<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token operator">%</span>len<span class="token punctuation">(</span>lis<span class="token punctuation">)</span>            <span class="token keyword">del</span> lis<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            i <span class="token operator">=</span> j<span class="token number">-1</span>        <span class="token keyword">return</span> lis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><h4 id="数学解法-约瑟夫环-O-n-☆☆☆☆"><a href="#数学解法-约瑟夫环-O-n-☆☆☆☆" class="headerlink" title="数学解法-约瑟夫环 O(n)            ☆☆☆☆"></a>数学解法-约瑟夫环 O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 通过最后的坐标反推一开始的坐标</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>res<span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token operator">%</span>i        <span class="token keyword">return</span> res</code></pre><h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66 构建乘积数组"></a>66 <a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">构建乘积数组</a></h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中b[i]的值是数组a中除了下标i以外的元素的积。</p><h4 id="对称遍历-O-n-☆☆☆☆"><a href="#对称遍历-O-n-☆☆☆☆" class="headerlink" title="对称遍历 O(n)            ☆☆☆☆"></a>对称遍历 O(n)            ☆☆☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constructArr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        b<span class="token punctuation">,</span>tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">*=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> tmp        <span class="token keyword">return</span> b</code></pre><h3 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67 把字符串转换成整数"></a>67 <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">把字符串转换成整数</a></h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p><h4 id="暴力法O-lgn-☆☆"><a href="#暴力法O-lgn-☆☆" class="headerlink" title="暴力法O(lgn)            ☆☆"></a>暴力法O(lgn)            ☆☆</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">strToInt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res<span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        int_max<span class="token punctuation">,</span>int_min <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span>        bndry <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span> <span class="token operator">//</span><span class="token number">10</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">:</span>            <span class="token keyword">pass</span>        <span class="token keyword">elif</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>            sign <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">elif</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 数字越界处理</span>                <span class="token keyword">if</span> res <span class="token operator">></span> bndry <span class="token operator">or</span> res <span class="token operator">==</span> bndry <span class="token operator">and</span> c <span class="token operator">></span> <span class="token string">'7'</span><span class="token punctuation">:</span>                     <span class="token keyword">return</span> int_max <span class="token keyword">if</span> sign<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">else</span> int_min                res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> sign</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Stat110 - Introduction to Probability代码的R语言与Python实现</title>
      <link href="/2020/04/07/stat110/"/>
      <url>/2020/04/07/stat110/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>这篇文章主要是用于记录将哈佛大学Stat110的教材用书《Introduction to Probability》第一版一书中的R代码向Python进行翻译转换，相关资源链接：<a href="http://stat110.net" target="_blank" rel="noopener">http://stat110.net</a></p></blockquote><p>&emsp;&emsp;本博文还在更新中，最新更新为<strong>27/04/2020, Chapter05</strong>，出于一些原因，暂时停更。建议你使用能够支持markdown的浏览器，如新版本chrome或edge来进行阅读，否则可能出现格式错乱问题。在完成以后会提供全文pdf文件。</p><p>&emsp;&emsp;R语言在科学计算上的确有很多优势，但是学习起来学习曲线比较陡峭，不太适合新手。我用惯了Python，想要同时把他们两都操作一下熟悉熟悉。以后的代码对比都以下面的形式或者表格形式来展现。国内需要使用R的话，建议直接到清华镜像下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CRAN/</a></p><p>&emsp;&emsp;<strong>注意：本博文只对书本上的代码进行介绍与翻译，对其相应的知识点只会粗略带过，需要读者自行进行学习。</strong></p><h1 id="Chapter-01"><a href="#Chapter-01" class="headerlink" title="Chapter 01"></a>Chapter 01</h1><p>&emsp;&emsp;对应原文1.8内容。</p><p>&emsp;&emsp;<strong>第一章总结：</strong></p><p>&emsp;&emsp;第一章主要讲了一些基础的概率论知识，诸如：朴素概率定义（其实就是古典概型）和他的一些重复运算的解决方法，以及一些概率的性质而已。</p><p>&emsp;&emsp;比较特别的是，第一单元里讲了一些Story Proof（故事论证）之类的东西让一些二项式系数公式的记忆变得尤为方便，而且里面举的很多例子都是很好帮助理解的内容，这是跟国内的教学差别很大的地方。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python">v <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将v定义为一组向量[3,1,4,1,5,9]</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">v <- c(3,1,4,1,5,9) # 将v定义为一组向量(3,1,4,1,5,9),c代表concatenate</code></pre><p>&emsp;&emsp;在Python里面此处用Numpy的数组做向量。与Python不同，R语言是建立在向量之上的，就算是简单的 <code>n &lt;- 100</code> 都被R视为一个长度为1的向量。</p><p>&emsp;&emsp;当然在R里面稍有不同的是，”=”与”&lt;-“使用上稍有不同，在函数调用中，func(x=1)与func(x&lt;-1)是有区别的，前者调用完后变量x不会被保留，而后者会在工作区里保留变量x=1。</p><p>&emsp;&emsp;R与Python不同的地方还是有挺多的：</p><table><thead><tr><th>Python</th><th>R</th><th>效果</th></tr></thead><tbody><tr><td>sum(v)</td><td>sum(v)</td><td>求和</td></tr><tr><td>max(v)</td><td>max(v)</td><td>求最大值</td></tr><tr><td>min(v)</td><td>min(v)</td><td>求最小值</td></tr><tr><td>len(v)</td><td>length(v)</td><td>获得长度</td></tr><tr><td>range(m,n+1)</td><td>m:n</td><td>m,m+1,…n-1,n</td></tr></tbody></table><p>&emsp;&emsp;在元素获取上，两者区别还是挺大的，最大区别还是从0还是1开始数：</p><table><thead><tr><th>Python</th><th>R</th><th style="text-align:left">输出</th></tr></thead><tbody><tr><td>v[0]</td><td>v[1]</td><td style="text-align:left">3</td></tr><tr><td>？（Python有吗）</td><td>v[-(2:4)]</td><td style="text-align:left">1 5 9</td></tr><tr><td>v[[0,2,4]]</td><td>v[c(1,3,5)]</td><td style="text-align:left">[3,4,5] / 3 4 5</td></tr><tr><td>[x**(-2) for x in range(1,101)]</td><td>1/(1:100)^2</td><td style="text-align:left">$(\frac{1}{1^2},\frac{1}{2^2},…,\frac{1}{100^2})$</td></tr></tbody></table><h2 id="阶乘与二项式"><a href="#阶乘与二项式" class="headerlink" title="阶乘与二项式"></a>阶乘与二项式</h2><p>&emsp;&emsp;在本来并不用于计算的Python中，运算这种需要调用别的库，例如阶乘：</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> mathmath<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span>n<span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">factorial(n)</code></pre><p>&emsp;&emsp;同样的也有像二项式，一般Python图方便会直接自己写一个函数，不过实在要调用也是可以的。</p><p><strong>Python</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> scipy<span class="token punctuation">.</span>special <span class="token keyword">import</span> combcomb<span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">choose(n,k)</code></pre><p>&emsp;&emsp;R相较之下真的太方便了。此外R还有lchoose(n,k)，lfactorial(n)用来运算log值，方便进行乘法转换加法。</p><h2 id="取样模拟"><a href="#取样模拟" class="headerlink" title="取样模拟"></a>取样模拟</h2><p>&emsp;&emsp;这方面二者用法是很相似的，直接上表格吧。</p><table><thead><tr><th>Python</th><th>R</th><th>效果</th></tr></thead><tbody><tr><td>np.random.choice(range(1,n+1),size=k,replace=False)</td><td>sample(n,k)</td><td>从1-n中不放回抽样k次</td></tr><tr><td>np.random.choice(range(1,n+1),size=k)</td><td>sample(n,k,replace=True)</td><td>从1-n中有放回抽样k次</td></tr><tr><td>np.random.choice([‘a’,’b’,…,’z’]),size=k,,replace=False)</td><td>sample(letters,k) #letters是R自带的26个小写字母表数组</td><td>从26个字符中取不重复地取字母组成k字符单词</td></tr><tr><td>np.random.choice(range(1,5),size=3,replace=False,p=[0.1,0.2,0.3,0.4])</td><td>sample(4, 3, replace=TRUE, prob=c(0.1,0.2,0.3,0.4))</td><td>1-4的概率分别为0.1,0.2,0.3,0.4</td></tr></tbody></table><h2 id="de-Montmort‘s-配对问题"><a href="#de-Montmort‘s-配对问题" class="headerlink" title="de Montmort‘s 配对问题"></a>de Montmort‘s 配对问题</h2><p>&emsp;&emsp;de Montmort’s配对问题指的是一堆卡片标有1-n的数字，打乱后一张一张的掀开，第k次掀开的若对应的数字正好为k，那么则视为成功，求的是整套卡片翻完的至少成功一次的概率。</p><p>&emsp;&emsp;单纯的运算需要运用Inclusion-exclusion公式：</p><p><img src="/2020/04/07/stat110/1-1.png" alt="de Montmort‘s"></p><p>&emsp;&emsp;而在代码里我们可以做simulation模拟。</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">100</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token operator">==</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> r<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">:</span>        count<span class="token operator">+=</span><span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token operator">/</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">n <- 100r <- replicate(10^4,sum(sample(n)==(1:n))) # 重复10^4次，计算n个不重复取样与1:n的相同个数总数sum(r>=1)/10^4</code></pre><p>&emsp;&emsp;R是真的简短很多，不愧是数字科学专用语言…不过说真的，python的代码相比之下更加友好。</p><h2 id="生日问题"><a href="#生日问题" class="headerlink" title="生日问题"></a>生日问题</h2><p>&emsp;&emsp;对于生日问题的概率计算，Python，所幸numpy也支持prod。</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python"><span class="token number">1</span><span class="token operator">-</span>np<span class="token punctuation">.</span>prod<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">365</span><span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">365</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">365</span><span class="token operator">**</span>k</code></pre><p><strong>R的话有两种方式：</strong></p><pre class=" language-R"><code class="language-R">1-prod((365-k+1):365)/365^k # 1.直接计算pbirthday(k) # 2.使用内置的函数</code></pre><p>&emsp;&emsp;还挺犯规的，生日问题都内置了。而且R还能用<code>qbirthday(n)</code>来计算达到n概率两人以上相同生日所需要的人数。而且对于这两个函数，还能加上coincident参数来指定特定多少人同一天生日，在这就不做示范了。</p><p>&emsp;&emsp;生日问题的模拟的话是这样：</p><p><strong>Python：</strong></p><pre><code>count = 0for i in range(10**4):    if Counter(np.random.choice(range(365),23)).most_common(1)[0][1]&gt;1:        count += 1print(count/10**4)</code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">r <- replicate(10^4, max(tabulate(sample(1:365,23,replace=TRUE)))) # 重复10^4次，计算23次从365个数重复取样取得相同次数最多的个数sum(r>=2)/10^4</code></pre><h1 id="Chapter-02"><a href="#Chapter-02" class="headerlink" title="Chapter 02"></a>Chapter 02</h1><p>&emsp;&emsp;对应原文2.10的内容</p><p>&emsp;&emsp;<strong>第二章总结：</strong></p><p>&emsp;&emsp;这一章很细致的讲了条件概率的各种东西，包括事件独立性，贝叶斯，全概率公式，多条件概率，条件的选择（三门问题，递归问题，Gambler’s ruin）各种谬误（Prosecutor’s fallcay，Simpson’s paradox)。</p><p>&emsp;&emsp;内容都十分深入浅出，有一说一，相比起国内大学蓝色那本概率统计真的细致太多了。</p><h2 id="模拟频率派的理解"><a href="#模拟频率派的理解" class="headerlink" title="模拟频率派的理解"></a>模拟频率派的理解</h2><p>&emsp;&emsp;这里用到书上的例子：</p><p>&emsp;&emsp;一个家庭两小孩（$A$和$B$），在 ($C_1$) 已知至少有一个是女孩 和 ($C_2$) 已知有一个姐姐 分别的条件下，求两人都是女孩的条件概率，设事件$S$为两人都是女孩。</p><p>&emsp;&emsp;这道题实际上就是求$P(S|C_1)$和$P(S|C_2)$。且因为前者是$\frac{1}{3}$而后者为$\frac{1}{2}$，让人觉得这道题的答案比较反直觉，但是其实却很合理。频率派的理解就是用大量实验去叠，那只需要取很多（这里取了$10^5$）个样就行。</p><p><strong>Python:</strong></p><pre class=" language-Python"><code class="language-Python">n = 10**5childa = np.random.choice([1,2],n,True)childb = np.random.choice([1,2],n,True)a = (childa==1) # 小孩A是女孩b = (childb==1) # 小孩B是女孩n_c1 = sum(a|b) # 至少一个女孩n_s = sum(a&b) # A和B都是女孩n_c2 = sum(a) # A是女孩p_1 = n_s/n_c1 # P(S|C1)p_2 = n_s/n_c2 # P(S|C2)print('P(S|C1)=%f,P(S|C2)=%f' % (p_1,p_2))</code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">n <- 10^5childa <- sample(2,n,replace=TRUE)childb <- sample(2,n,replace=TRUE)n.b <- sum(childa==1) # A是女孩n.b2 <- sum(childa==1 | childb==1) # 至少一个女孩n.ab <- sum(childa==1 & childb==1) # A和B都是女孩n.ab/n.b # P(S|C2)n.ab/n.b2 # P(S|C1)</code></pre><p>&emsp;&emsp;得到两个值一个接近0.33，另一个接近0.5，模拟完成。</p><h2 id="三门问题模拟"><a href="#三门问题模拟" class="headerlink" title="三门问题模拟"></a>三门问题模拟</h2><p>&emsp;&emsp;三门问题又称<em>Monty Hall</em>问题，比较经典的一个条件概率问题，在这里就不介绍了上网可以查到，可能之后会补充。先放一个书上的R语言版本，他加了一点交互式来进行模拟游戏：</p><pre class=" language-R"><code class="language-R">monty <- function() {    doors <- 1:3    # randomly pick where the car is    cardoor <- sample(doors,1)    # prompt player    print("Monty Hall says ‘Pick a door, any door!’")    # receive the player’s choice of door (should be 1,2, or 3)    chosen <- scan(what = integer(), nlines = 1, quiet = TRUE)    # pick Monty’s door (can’t be the player’s door or the car door)    if (chosen != cardoor) montydoor <- doors[-c(chosen, cardoor)]    else montydoor <- sample(doors[-chosen],1)    # find out whether the player wants to switch doors    print(paste("Monty opens door ", montydoor, "!", sep=""))    print("Would you like to switch (y/n)?")    reply <- scan(what = character(), nlines = 1, quiet = TRUE)    # interpret what player wrote as "yes" if it starts with "y"    if (substr(reply,1,1) == "y") chosen <- doors[-c(chosen,montydoor)]    # announce the result of the game!    if (chosen == cardoor) print("You won!")    else print("You lost!")}</code></pre><p>&emsp;&emsp;R的代码用来写这种程序实在是…有点尴尬，交互和代码可读性过于差了。我的话，是尝试利用频率派的方式模拟，来计算多次三门问题分别在使用了 <strong>策略1： 一直换门 </strong> 和 <strong>策略2：绝不换门</strong> 之下的概率，感觉这样对比更有实际意义。</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">def</span> <span class="token function">MontyHall</span><span class="token punctuation">(</span>n_select<span class="token punctuation">,</span> is_change<span class="token punctuation">)</span><span class="token punctuation">:</span>    n_car <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> n_select <span class="token operator">==</span> n_car<span class="token punctuation">:</span>        <span class="token keyword">if</span> is_change<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> is_change<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true"># strategy of always changing doors    </span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    n_select <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> MontyHall<span class="token punctuation">(</span>n_select<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Prob of changed'</span><span class="token punctuation">,</span> count<span class="token operator">/</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Strategy of always NOT changing doors   </span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    n_select <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> MontyHall<span class="token punctuation">(</span>n_select<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Prob of not changed'</span><span class="token punctuation">,</span> count<span class="token operator">/</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">monty <- function(n_selected, is_change) {    n_car <- sample(3,1)    if(is_change){        if(n_car == n_selected){            return(FALSE)        }else{            return(TRUE)        }    }    else{        if(n_car == n_selected){            return(TRUE)        }else{            return(FALSE)        }    }}# Strategy of always changing doorsr <- replicate(n=10^4,monty(sample(3,1),TRUE))sum(r/10^4)# Strategy of always NOT changing doorsr <- replicate(n=10^4,monty(sample(3,1),FALSE))sum(r/10^4)</code></pre><p>&emsp;&emsp;得到两个值一个接近0.33，另一个接近0.66，完事了。</p><p>&emsp;&emsp;不过从这代码啊就可以看出来，Python相较于R还是更加万金油一点，Python写循环写嵌套都是比较清晰的，R这个语法就写这么个小函数却实在把用惯Java，Python之类语言的我糊弄的难顶。（扶额）</p><h1 id="Chapter-03"><a href="#Chapter-03" class="headerlink" title="Chapter 03"></a>Chapter 03</h1><p>&emsp;&emsp;对应原文3.11内容。</p><p>&emsp;&emsp;<strong>第三章总结：</strong></p><p>&emsp;&emsp;第三章开始讲随机变量了，这一章和下一章好像都是只讲离散型。</p><p>&emsp;&emsp;这一章只讲了几个常见离散分布，除了Bernoulli和Binomial以外，还有一个在国内大学概率论好像不接触，叫超几何分布HyperGeometric，虽然听的挺多但是正式去了解还是第一次。</p><p>&emsp;&emsp;印象中除了这些分布以外，还有他讲的内容也很特别。例子有很多，包括PMF，CDF的定义证明之类的，上面三个分布的联系之类的，不过让我印象最深刻的还是他给随机变量与分布关系的定义：</p><blockquote><p>分布之于随机变量，就像蓝图之于房子。不同的房子可以用同样的蓝图，而不同的随机变量也能有相同的分布。</p></blockquote><p>&emsp;&emsp;书本内容真的很深入浅出，不过继续代码吧。（本章代码省略了离散型均匀分布部分，那部分连Stat110上课都没讲，因为无非就是古典概型取样，可以参照第一章内容）</p><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>&emsp;&emsp;贝努利分布就没必要整了，就是一次二项分布。以在$X\sim{Bin(5,0.2)}$当$X=3$为例子。</p><p>&emsp;&emsp;（国内一般用的标识应该是$X\sim{B(5,0.2)}$）</p><p><strong>Python：</strong></p><pre><code># Python需要用到scipy的stats模块from scipy.stats import binomprint(&#39;P(X=3):&#39;,binom.pmf(3,5,0.2),&#39;\nF(X=3):&#39;, binom.cdf(3,5,0.2))print(&#39;Samples of X~Bin(5,0.2)&#39;,binom.rvs(size=7,n=5,p=0.2))# 输出：&gt; P(X=3): 0.051200000000000016 &gt; F(X=3): 0.99328&gt; array([2, 1, 1, 1, 1, 2, 0])</code></pre><p><strong>R:</strong></p><pre><code>dbinom(3,5,0.2) # PMFpbinom(3,5,0.2) # CDFrbinom(7,5,0.2) # 从分布中随机取样7个#输出[1] 0.0512[2] 0.99328[3] 1 2 1 2 3 2 2</code></pre><p>&emsp;&emsp;很显然，R的代码辨识度是真的不好。相比之下Python用户体验还是很好的，难怪支持者两极分化严重。</p><h2 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h2><p>&emsp;&emsp;废话不多说，对于PMF，CDF和取样的做法大同小异，要不是书上有我也不写了，直接上表格算了。</p><p>&emsp;&emsp;超几何分布标识一般是这样$X\sim{HGeom(w,b,n)}$，不过也有是这样标识的$X\sim{G(n,M,N)}$，这两种标识正好代表了在R和在Python里的不同用法。（R是用第一个，而Python是第二个）</p><p>&emsp;&emsp;先简单的说明一下，超几何分布其实就是不放回取样的成功数。而$X\sim{HGeom(w,b,n)}$里，$w$代表了所有样本中成功的样本数，$b$代表所有样本中失败的样本数，$n$代表取样的数目。而在标识$X\sim{G(n,M,N)}$里，$n$还是代表取样本数，而$M$代表所有样本数，$N$表示成功的样本数。</p><p>&emsp;&emsp;的确有所区别，不过大同小异，Python的话记得import调包就完事了。</p><table><thead><tr><th>Python</th><th>R</th></tr></thead><tbody><tr><td>hypergeom.pmf(k=5,n=8,M=30,N=10)</td><td>dhyper(5,10,20,8)</td></tr><tr><td>hypergeom.cdf(k=5,n=8,M=30,N=10)</td><td>phyper(5,10,20,8)</td></tr><tr><td>hypergeom.rvs(size=10,n=8,M=30,N=10)</td><td>rhyper(10,10,20,8)</td></tr></tbody></table><h1 id="Chapter-04"><a href="#Chapter-04" class="headerlink" title="Chapter 04"></a>Chapter 04</h1><p>&emsp;&emsp;对应原文4.11内容。</p><p>&emsp;&emsp;<strong>第四章总结：</strong></p><p>&emsp;&emsp;第四章整的东西还挺多，把全部常用的离散型分布给讲完了，而且还挺多的，包括几何分布、第一次成功分布、负二项分布和泊松分布，还有诸如期望、方差的定义与性质。这一章最有意思的还是一个随机变量标识器（Indicator r.v.s）的思想，在分析的时候尤其是对期望分析的时候特别有用。</p><h2 id="几何分布、负二项分布、泊松分布"><a href="#几何分布、负二项分布、泊松分布" class="headerlink" title="几何分布、负二项分布、泊松分布"></a>几何分布、负二项分布、泊松分布</h2><p>&emsp;&emsp;因为第一次成功分布（First Success Distribution)就是几何分布的随机变量加一，没什么好说的，就先把这三个简单罗列一下吧。Python同样使用的是Scipy.stats模块。</p><table><thead><tr><th>Python</th><th>R</th><th>Distribution</th></tr></thead><tbody><tr><td>geom.pmf/cdf/rvs</td><td>d/p/rgeom</td><td>$X\sim{Geom(p)}$</td></tr><tr><td>nbinom.pmf/cdf/rvs</td><td>d/p/rnbinom</td><td>$X\sim{NBin(r,p)}$</td></tr><tr><td>possion.pmf/cdf/rvs</td><td>d/p/rpois</td><td>$X\sim{Pois(\lambda{})}$</td></tr></tbody></table><h2 id="求期望"><a href="#求期望" class="headerlink" title="求期望"></a>求期望</h2><p>&emsp;&emsp;书上是直接用了第一章Matching Problem的例子来求期望。按道理这里的期望模拟得到会十分接近于 1，至于为什么有兴趣的各位请看书吧，在<strong>Example 4.4.4</strong>上利用了随机变量标识器来进行计算得到的。</p><p><strong>Python:</strong></p><pre><code>n = 100count = 0r = []for i in range(10**4):    r.append(sum(np.random.choice(range(1,n+1),n,replace=False)==range(1,n+1)))print(np.mean(r))</code></pre><p><strong>R:</strong></p><pre><code>n &lt;- 100r &lt;- replicate(10^4,sum(sample(n)==(1:n)))mean(r)</code></pre><h2 id="另一个生日问题模拟"><a href="#另一个生日问题模拟" class="headerlink" title="另一个生日问题模拟"></a>另一个生日问题模拟</h2><p>&emsp;&emsp;这一个生日问题来自<strong>Example 4.4.5</strong>，也是一个随机变量标识器的例子。意思是有n个人，求365天里至少有一人生日的日子数的期望值。这个值会无限接近于$365(1-(\frac{364}{365})^n)$，这里例子取$n=20$。</p><p><strong>Python:</strong></p><pre><code>import numpy as npk = 20r = []for i in range(10**4):    r.append(len(np.unique(np.random.choice(range(1,365+1),k,True))))print(np.mean(r))</code></pre><p><strong>R:</strong></p><pre><code>k &lt;- 20r &lt;- replilcate(10^4, {bdays &lt;- sample(365,k,replace=TRUE); length(unique(bdays))})mean(r)</code></pre><h1 id="Chapter-05"><a href="#Chapter-05" class="headerlink" title="Chapter 05"></a>Chapter 05</h1><p>&emsp;&emsp;对应原文5.9内容。</p><p>&emsp;&emsp;<strong>第五章总结：</strong></p><p>&emsp;&emsp;第五章完成了基本上是这个课程的一半了，内容还不少。虽然这篇博文注重代码，但还是把一个很重要的表格(见下图)放上来一下。这一章讲的是连续型随机变量以及各种连续型分布，包括均匀分布、Logistic分布、Rayleigh分布、正态分布与指数分布，还稍微提了提泊松过程。</p><p><img src="/2020/04/07/stat110/5-1.png" alt="fff"></p><p>&emsp;&emsp;这一章比较重点的内容是：位置-刻度转换思想(Location-scale transformation)，均匀分布的普适性(Universality of the Uniform)</p><h2 id="均匀分布、正态分布、指数分布等"><a href="#均匀分布、正态分布、指数分布等" class="headerlink" title="均匀分布、正态分布、指数分布等"></a>均匀分布、正态分布、指数分布等</h2><p>&emsp;&emsp;把这几个简单罗列一下吧。Python同样使用的是Scipy.stats模块。在命名上和上一次的超几何分布的参数上就可以看出来R语言很倾向数学上的命名法，不过暂时我没找到R写的Rayleigh分布。</p><table><thead><tr><th>Python</th><th>R</th><th>Distribution</th></tr></thead><tbody><tr><td>uniform.pmf/cdf/rvs</td><td>d/p/runif</td><td>$X\sim{Unif(a,b)}$</td></tr><tr><td>norm.pmf/cdf/rvs</td><td>d/p/rnorm</td><td>$X\sim{N(\mu,\sigma^2)}$</td></tr><tr><td>expon.pmf/cdf/rvs</td><td>d/p/rexp</td><td>$X\sim{Expo(\lambda)}$</td></tr><tr><td>logistic.pmf/cdf/rvs</td><td>d/p/rlogis</td><td>$X\sim{Logistic}$</td></tr><tr><td>rayleigh.pmf/cdf/rvs</td><td>?</td><td>$X\sim{Rayleigh}$</td></tr></tbody></table><p>&emsp;&emsp;顺便在这里用正态分布表演一个location-scale变换。</p><p>&emsp;&emsp;由$\frac{X-\mu}{\sigma}\sim{N(0,1)}$来获得$X\sim{N(\mu,\sigma^2)}$，此处$\mu=1$，$\sigma=2$。</p><p><strong>Python:</strong></p><pre><code>import matplotlib.pyplot as pltmu = 1sigma = 2x = mu + sigma * norm.rvs(size=10**4)plt.hist(x) # 效果如下图</code></pre><p><img src="/2020/04/07/stat110/5-3.png" alt="fff"></p><p><strong>R:</strong></p><pre><code>mu &lt;- 1sigma &lt;- 2x &lt;- mu + sigma * rnorm(10^4)hist(x) # 效果如下图</code></pre><p><img src="/2020/04/07/stat110/5-2.png" alt="fff"></p><p>&emsp;&emsp;R和Python在这方面上几乎完全一致，不用怎么翻译就很舒服。</p><h2 id="画曲线"><a href="#画曲线" class="headerlink" title="画曲线"></a>画曲线</h2><p>&emsp;&emsp;再用标准正态分布在[-3,3]上的图整个pdf。</p><p><strong>Python:</strong></p><pre><code>x = np.arange(-3,3,0.01)y = norm.pdf(x)plt.plot(x,y) # 效果如下图</code></pre><p><img src="/2020/04/07/stat110/5-4.png" alt="fff"></p><p><strong>R有两种方式:</strong></p><pre><code># 第一种跟Python一样x &lt;- seq(-3,3,0.01)y &lt;- dnorm(x)plot(x,y,type=&#39;l&#39;)# 第二种：R独有的curve(dnorm, from=-3,to=3,n=1000) # 效果如下图</code></pre><p><img src="/2020/04/07/stat110/5-5.png" alt="fff"></p><h2 id="均匀分布的普适性模拟"><a href="#均匀分布的普适性模拟" class="headerlink" title="均匀分布的普适性模拟"></a>均匀分布的普适性模拟</h2><p>&emsp;&emsp;这里用Logistic分布来实现普适性的一个效果，即$log(\frac{U}{1-U})\sim{Logistic}$。</p><p><strong>Python:</strong></p><pre><code>import numpy as npfrom scipy.stats import uniformfrom scipy.stats import logisticimport matplotlib.pyplot as pltplt.figure(figsize=(13, 5)) #调整图像大小# 使用普适性u = uniform.rvs(size=10**4)x = np.log(u/(1-u))plt.subplot(1,2,1)plt.hist(x,bins=20)# 直接获取分布plt.subplot(1,2,2)x = np.arange(-10,10,0.01)y = logistic.pdf(x)plt.plot(x,y)plt.show()</code></pre><p><img src="/2020/04/07/stat110/5-6.png" alt="fff"></p><p><strong>R:</strong></p><pre><code># 使用普适性u &lt;- runif(10^4)x &lt;- log(u/(1-u))hist(x)# 直接获取分布curve(dlogis, from=-15,to=15,n=1000)</code></pre><p><img src="/2020/04/07/stat110/5-7.png" alt="fff"></p><p>&emsp;&emsp;反正就是输出跟直接获取分布走势很像，就模拟认为他可行了。</p><h2 id="泊松过程模拟与验证"><a href="#泊松过程模拟与验证" class="headerlink" title="泊松过程模拟与验证"></a>泊松过程模拟与验证</h2><p>&emsp;&emsp;指数分布与泊松分布有联系。指数分布每一个值是发生下一次无记忆性事件的时间点，所以是连续的。泊松分布可以视作单位时间内发生事件的次数。那么，对于rate为$\lambda$的泊松过程，会有，</p><ul><li><p>间隔为1的时间段内发生事件的次数服从$Pois(\lambda)$</p></li><li><p>每次事件发生的时间间隔服从$Expo(\lambda)$</p></li></ul><p>&emsp;&emsp;下面来用指数分布生成时间间隔的方式验证”时间段内次数服从泊松分布”：</p><p><strong>Python:</strong></p><pre><code>import numpy as npfrom scipy.stats import exponfrom scipy.stats import poissonimport matplotlib.pyplot as pltplt.figure(figsize=(13, 5)) #调整图像大小# 泊松过程lamb = 10r = []for i in range(10**4):    r.append(sum(np.cumsum(expon.rvs(size=20,scale=1/lamb))&lt;1))plt.subplot(1,2,1)plt.hist(r,bins=20)# 泊松分布x = list(range(21))y = poisson.pmf(x,mu=lamb)plt.subplot(1,2,2)plt.plot(x,y)plt.show()</code></pre><p><img src="/2020/04/07/stat110/5-9.png" alt="fff"></p><p><strong>R:</strong></p><pre><code># 泊松过程lambda = 10r = replicate(10^4,sum(cumsum(rexp(20,lambda))&lt;1))hist(r)# 泊松分布x &lt;- 0:20y &lt;- dnorm(x,lambda)plot(x,y,type=&#39;l&#39;)</code></pre><p><img src="/2020/04/07/stat110/5-8.png" alt="fff"></p><p>&emsp;&emsp;图像都接近，完事了。</p><p>&emsp;&emsp;要注意的是，对于Python与R的pmf函数，pdf函数之类的，参数都不太一样，所以必须要看清楚再输入。举这里的例子：</p><p>&emsp;&emsp;在Python中，指数分布的pdf/cdf/rvs调整参数是通过location-scale转换来调整的，这是他的参数：<code>expon.pdf(x,loc=0,scale=1)</code>。</p><p>&emsp;&emsp;所以我为了获得$\lambda=10$的指数分布，输入了scale=1/10。</p><p>&emsp;&emsp;而在R中，参数是这样的<code>dexp(k,rate=1)</code>，那么直接输入rate=10即可。</p><p>&emsp;&emsp;同理，对于泊松分布，Python里要输入参数的也不是$\lambda$，而是$\mu=\lambda t$。所以在这里我们取单位时间1，这时$\mu=\lambda$。而R中直接就是输入$\lambda$的值作为参数即可。二者区别还是很大的，总而言之还是R偏向数学用语。</p><p>&emsp;&emsp;对于泊松过程详细内容请尽量参考书本或别的资料，在此不会详细解释。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Probability </tag>
            
            <tag> R </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高位水仙花数算法优化</title>
      <link href="/2018/11/10/narcissistic/"/>
      <url>/2018/11/10/narcissistic/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>算法思路：<br>以三位的水仙花数为例——</p><ol><li>432各位立方幂和为99，小于100，则不能使用；</li><li>433各位立方幂和为118，但118并不由4 3 3三个数组成，则不是水仙花数；</li><li>531各位立方和为153，且153由5 3 1组成，则是水仙花数；</li><li>777各位立方和为1029，大于999，则不能使用，结束循环。</li></ol><p>再通过预处理（初始化0~9的N次幂）+递归减少运算量。<br>直接看代码吧：</p><pre><code>import java.math.BigInteger;/** * @class: Narcissistic * @author: Chitose * @date: 2018/11/11 * @description: */public class Narcissistic  {    public static int size = 21;    public static BigInteger powArray[] = new BigInteger[10]; // 记录0~9的size次方    public static int usedTimes[] = new int[10];// 记录0~9的使用次数    public static BigInteger powArrayTimes[][]; //记录0到9中任意数字i的N次方乘以其出现的次数j的结果（i^N*j）    public static BigInteger MAX; // size位的数字能表示的最大值    public static BigInteger MIN; // size位的数字能表示的最小值    public static void main(String[] args) {        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10; i++) {// 初始化powArray[]            powArray[i] = (new BigInteger(&quot;&quot; + i)).pow(size);        }        MIN = BigInteger.valueOf(10).pow(size - 1); // 初始化最小值        MAX = BigInteger.valueOf(10).pow(size);     // 初始化最大值（不能等于这个值）        powArrayTimes = new BigInteger[10][size + 1];  //初始化powArrayTimes[][]        for (int i = 0; i &lt; 10; i++) {            powArrayTimes[i][0] = BigInteger.valueOf(0);            for (int j = 1; j &lt; size + 1; j++) {                powArrayTimes[i][j] = powArrayTimes[i][j - 1].add(powArray[i]);            }        }        solve(9, 0, BigInteger.ZERO);        long end = System.currentTimeMillis();        System.out.println(end-start+&quot;毫秒&quot;);    }//index:当前轮到的0~9数字   used:当前已使用的数字总数   now:当前各数字幂和    static void solve(int index, int used, BigInteger now){        if(index == 0){                     //若index到0了则剩下的全部都是0            usedTimes[0] = size - used;            solve(-1, size, now);            usedTimes[0] = 0;            return;        }        if(used == size){            if(now.compareTo(MIN)&lt;0) {      //若现在值还是小于最小值，退出                return;            }            String strNow = now.toString();            int realUsedTimes[] = new int[10];                  // 记录真实的数中0~9的使用次数            for(int i = 0 ; i &lt; strNow.length() ; i++){                realUsedTimes[strNow.charAt(i)-&#39;0&#39;]++;            }            for(int i = 0 ; i &lt; 10 ; i++){                if(realUsedTimes[i] != usedTimes[i]) {          //若比对真实值与使用数不同则退出递归                    return;                }            }            System.out.println(now);                            //如果0~9的使用次数都相同才打印            return;        }        //递归主要部分        for(int i = 0 ; i &lt; size - used ; i++){            if(now.add(powArrayTimes[index][i]).compareTo(MAX)&gt;=0){          //如果已经超过最大值直接退出这一层递归                return;            }            usedTimes[index] = i;       //使用i次index的数            solve(index-1, used+i, now.add(powArrayTimes[index][i]));            usedTimes[index] = 0;       //还原使用次数        }    }}</code></pre><p>以21位的水仙花数做例子，输出如下：</p><blockquote><p>128468643043731391252<br>449177399146038697307<br>4.155秒</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程（二）——JMM与线程安全</title>
      <link href="/2018/11/09/thread2/"/>
      <url>/2018/11/09/thread2/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><em>这一篇将涉及比较多底层知识，代码较少但都是干货。</em></p><hr><h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM (Java Memory Model)"></a><strong>JMM</strong> <em>(Java Memory Model)</em></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在讲线程安全之前必须提及Java内存模型，因为线程安全是与它息息相关的。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先，JMM是一个抽象的规范，它本身不存在，通过JMM，JVM虚拟机可以屏蔽掉各种硬件或者操作系统的差异，规范了JVM如何与计算机内存协同工作的、线程之间共享资源的方式（如一个线程如何看到其他线程修改后的变量，同步访问共享变量等）。<br><img src="/2018/11/09/thread2/JMMDetail.png" alt="JMM"><br>&nbsp;&nbsp;&nbsp;&nbsp;如图，Java内存模型规定了所有变量都存储在主内存中<em>（即图中的Heap，主内存有时候也称堆内存）</em>，即主内存是任何线程都能访问到的。</p><ul><li>存放：所有<strong>对象</strong>及他们的成员变量、数组元素、静态域</li><li>优点：他是运行时的数据区，运行时动态分配内存的，生存期不必实现确定，由Java垃圾回收管理</li><li>缺点：存取速度相对较慢</li><li>Tips：只有获得对象的引用的变量才能被获得该引用的线程所访问</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM运行的单位（实体）实际上就是线程，每个线程创建时JVM都会为它分配一个私有的工作内存<em>（即图里的Thread Stack，它有时候也被称为线程栈）</em>，不同线程间无法访问，用于存放该线程拥有的变量。</p><ul><li>存放：基本类型<strong>变量</strong>（包括局部变量与方法变量等）以及对象的引用</li><li>优点：存取速度十分快，仅次于CPU的寄存器</li><li>缺点：生存期与大小必须事先确定</li><li>Tips：当要一个线程要引用一个变量的时候，实际上是该线程从主内存获得一份<strong>私有拷贝</strong>到工作内存中去，在写操作时会再写回。</li></ul><blockquote><p><strong>注意：必须搞清楚一件事是Java的内存划分与Java内存模型是不同层次的概念！</strong><br>关于Java的内存划分我会在本文最后放出相应的图示与解释。<br>此处JMM定义的主内存可以说是Java内存区域划分中的：堆与方法区<br>而工作内存则是：程序计数器、虚拟机栈及本地方法栈</p></blockquote><h3 id="同步八操作"><a href="#同步八操作" class="headerlink" title="同步八操作"></a>同步八操作</h3><p>图示为Java内存模型的操作：<br><img src="/2018/11/09/thread2/JMM.jpg" alt="JMM"><br><em>如果了解计算机的缓存一致性MESI的人应该能看得出来Java内存模型跟多处理机进行缓存一致性操作有异曲同工之妙，至于那是什么可以去搜一下或者看在本文最后的东西。</em></p><p><strong>lock(锁定)</strong>：作用于主内存，让主内存变量标示为某一线程的独占的状态。<br><em>当进行lock时会使工作内存中的该变量清空，在执行前需重新执行load和assign</em></p><p><strong>unlock(解锁)</strong>：作用于主内存，让主内存变量的独占状态解除，可以被其他线程锁定。<br>。<em>进行unlock必须先把该变量从之前锁定的线程的工作内存中同步到主内存</em></p><p><strong>read(读取)</strong>：作用于主内存的变量，把一个变量值从主内存读取到线程的工作内存中，以便于load的操作。<br><em>load与read不能单独出现！</em></p><p><strong>load(载入)</strong>：作用于工作内存的变量，把主内存read到的变量放入工作内存的变量副本中。<br><em>一个新变量是只能在主内存中诞生，不允许工作内存中用一个未被初始化的变量，即use和store之前必须有load和assign</em></p><p><strong>use(使用)</strong>：作用于工作内存的变量，将变量副本取出来到执行引擎中执行。</p><p><strong>assign(赋值)</strong>：作用于工作内存的变量，将执行引擎中收到的值赋予工作内存中的变量。<br><em>一个线程assign过的变量必须从工作内存写回主内存</em></p><p><strong>store(存储)</strong>：作用于工作内存的变量，将工作内存的变量存入主内存中，便于进行write操作。<br><em>store与write不能单独出现！</em></p><p><strong>write(写入)</strong>：作用于主内存的变量，把store的变量传到主内存的变量中。</p><p>当在多线程环境进行这同步八操作的时候，就有可能引致线程安全问题。那什么是线程安全？</p><h2 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程安全是指在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，得到预期想要的效果，不会出现数据污染等意外情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;而线程安全主要从三个方面来考察：原子性、可见性、有序性。</p><ul><li><strong>原子性</strong>：指不可分割性，互斥访问的操作（同一时刻只能有一个线程进行的操作）；</li><li><strong>可见性</strong>：指线程之间，一个线程对主内存修改的结果，另一个线程能马上正确的看到；</li><li><strong>有序性</strong>：一个线程观察其他线程的指令执行顺序，在必要的执行顺序错误则无序（CPU会为提高速度而进行乱序执行优化）。</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>因为前面讲了线程池真™好啊，这里就用线程池做例子了。</p><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //线程池大小    public static int threadTotal = 50;    //计数器    private static int count = 0;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}    //由于main可能先比线程池的任务执行的快，所以在这等待，让所有队列中的线程完成后再结束        System.out.println(&quot;count (should be 1000) : &quot; + count);    }    private static void add(){        count++;    }}</code></pre><p> 很明显，这串代码就是为了用一千个任务（任务就是每个任务都给一个共享的count加1）得到一个一千的值，所以如果输出<code>count (should be 1000) : 1000</code>的话就是我们想看到的。那么就执行这代码几次试试：</p><blockquote><p>count (should be 1000) : 979<br> count (should be 1000) : 956<br> count (should be 1000) : 982<br> count (should be 1000) : 965<br> count (should be 1000) : 973</p></blockquote><p>没有一次是达到目的的，每次都比1000少那么点，那问题出在哪里了呢？</p><p>相信是个人都知道x++这种自增符的用处相当于x=x+1，即先取出x的值，计算x+1，并把这个值传入到x里。<br>这里既有读操作也有写操作，写操作依赖于读操作，而这整个x++并非是一个原子性的操作，所以很有可能会产生这样的情况：线程1读完x=1后线程1准备写x=2的时候，线程2还在读之前的x=1，然后线程2写的时候也是写x=2，那么这两个线程本应该加到3也只能加到2。</p><p>那么这样就很清楚了为什么会发生这样的线程不安全问题了。</p><p>关于原子性，有几个常见的解决方法：</p><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //允许同时并发执行数    public static int threadTotal = 50;    //计数器    private static Integer count = 0;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}        System.out.println(&quot;count (should be 1000) : &quot; + count);    }    private synchronized static void add(){        count++;    }    //      这个也行：    //      private static void add(){    //      synchronized (ConcurrencyExample.class) {    //        count++;    //      }    //  }    //      但这个不行：    //      private static void add(){    //      synchronized (count) {    //        count++;      //每次执行这个，count都默认指向一个新的变量，那么锁就失效了    //      }    //  }}</code></pre><blockquote><p>count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000</p></blockquote><p>通过synchronized关键字，使任何线程进入代码块之前获得同步监视器锁，其他线程将不能获得同步锁而只能等待直到锁的释放。这里方法同步，对调用该方法的实例上锁，每次只能由一个线程获得锁来访问add()方法，那么效果便就如我们所愿了。<br>但是synchronized有时并不能满足我们的需求，首先sync只有完成了锁定的代码段才会解锁（或者其他如异常抛出或者wait()），不可中，，而且他是一种基于JVM的隐式锁，若里面代码片段过于复杂的时候就会资源占用，在竞争激烈的时候会导致性能下降，那么反而失去了多线程的必要性。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Java SE5提供了一种显锁式锁：ReentrantLock，通过显示的调用lock与unlock的方式进行锁定</p><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //允许同时并发执行数    public static int threadTotal = 50;    //计数器    private static int count = 0;    private static final ReentrantLock lock  = new ReentrantLock();    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}        System.out.println(&quot;count (should be 1000) : &quot; + count);    }    private static void add(){        lock.lock();        count++;        lock.unlock();    }}</code></pre><p>实际上与synchronized没太多区别，主要是Lock有一个比较特别的多一个tryLock()，能让其他线程如果获得不到锁去做别的事，而能更灵活的使用锁。</p><h3 id="Atomic类"><a href="#Atomic类" class="headerlink" title="Atomic类"></a>Atomic类</h3><p>J.U.C(Java.util.concurrency)包内提供了一些十分有用的原子类如：AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference、LongAdder等<br>这里简单演示其中一个：</p><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //允许同时并发执行数    public static int threadTotal = 50;    //计数器    private static AtomicInteger count = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}        System.out.println(&quot;count (should be 1000) : &quot; + count.get());    }    private static void add(){        count.incrementAndGet();        //相当于自增    }}</code></pre><blockquote><p>count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000</p></blockquote><p> 在此AtomicInteger的原子类是线程安全的，这些原子类的实现都是基于一个CAS算法，我们可以看看那个AtomicInteger的内部：<br> <img src="/2018/11/09/thread2/CAS.png" alt="CAS?"><br> 然后再进去看看：<br> ，var1是传入的对象，var2是对象当前的值，var4为加数，var5是通过getIntVolatile()方法获得对象的底层值，通过在死循环里不停使用compareAndSwapInt（就是CAS）比较对象的当前值与其底层值，这里的compareAndSwapInt是Unsafe类中的一个native本地内部方法，若不相同则返回false，若相同则将其值更新为var5+var4。<br> <img src="/2018/11/09/thread2/CAS2.jpg" alt="CAS"><br> 原子类都是通过这种CAS算法来进行安全的修改。</p><p> 顺带讲一种用法，<br> <strong>懒汉单例模式</strong>：</p><pre><code> public class LazySingletonExample {    private LazySingletonExample(){}    private static LazySingletonExample instance = null;    public static synchronized LazySingletonExample getInstance(){        if(instance == null){            instance = new LazySingletonExample();        }        return instance;    }}</code></pre><p>这是懒汉单例模式的一种写法，而在这里通过给getInstance()工厂方法加上synchronized关键字才保证了线程安全，否则会可能导致返回错误值。<br>但是前面也提到了使用方法同步的方式实际上大大降低性能，因为同一时间只能有一个线程能访问对象，所以这种单例模式虽然是线程安全，但是并不推荐，那么我们可以在其之上进行改进，<br>双重同步锁单例模式：</p><pre><code>public class DoubleLazySingletonExample {    private DoubleLazySingletonExample(){}    private static DoubleLazySingletonExample instance = null;    public static synchronized DoubleLazySingletonExample getInstance(){        if(instance == null){                                           //**Mark1**            synchronized (DoubleLazySingletonExample.class) {                if(instance == null) {                    instance = new DoubleLazySingletonExample();        //**Mark2**                }            }        }        return instance;    }}</code></pre><p>通过在里面使用双重锁定来保证了性能的提高，在已经有对象的时候直接不进入sync代码块，不至于让线程一直等待而无法同时使用对象。但是这里仍然有缺陷，假设有这样的情况：<br>首先对象初始化的过程是这样的：</p><ol><li>分配对象内存空间</li><li>初始化对象</li><li><p>使对象指向内存<br>1和（2,3）是不会发生指令重排的，但若2.3.发生指令重排，Thread1完成了3，Thread在Mark1位置判断instance时，因为不为空返回了值，但实际上还是没有初始化，所以非线程安全。所以这时需要给instance加上volatile关键字就解决重排序的问题了，这时这个单例模式便是线程安全的且性能较高：</p><pre><code>public class DoubleLazySingletonExample {private DoubleLazySingletonExample(){}//volatile+双重同步锁private volatile static DoubleLazySingletonExample instance = null;public static synchronized DoubleLazySingletonExample getInstance(){    if(instance == null){                                           //Mark1-Thread2        synchronized (DoubleLazySingletonExample.class) {            if(instance == null) {                instance = new DoubleLazySingletonExample();        //Mark2-Thread1            }        }    }    return instance;}}</code></pre></li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>对可见性可以举一个例子：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当线程1修改工作内存中的值的时候，必须要写回主内存才能被其他线程看到，但若没有写回就被线程2读的话，就会导致不可见。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;由此易知，导致不可见的原因：</p><ul><li>线程的交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主内存间及时更新</li></ul><h3 id="synchronized-Lock"><a href="#synchronized-Lock" class="headerlink" title="synchronized/Lock"></a>synchronized/Lock</h3><p>如何用锁保证可见性应该是显而易见的了，但还是在这里顺便说一下锁的原理：</p><ul><li>每次获得锁之前，会将所有工作内存中该变量的值清空</li><li>每次释放锁之前，必须把工作内存中变量最新值写回主内存<br>通过这种方式便能保证其他线程读到的是线程改动后的最新值。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile实际上是通过内存屏障禁止重排序来实现可见性的：</p><ul><li>对volatile变量进行write操作的时候，写后加入一条store屏障，将本地内存中共享变量刷到主内存去，那么store指令会在写操作后把最新的值强制刷新到主内存中。同时还会禁止cpu对代码进行重排序优化。这样就保证了值在主内存中是最新的。</li><li>对volatile变量进行read操作的时候，加入一条load屏障，load指令会在读操作前把内存缓存中的值清空后，再从主内存中读取最新的值。<br>实际上可以说是相当于volatile变量的操作是在主内存上进行操作的，因而时刻保证其最新值。<br><img src="/2018/11/09/thread2/vwrite.png" alt="volatile write"><br><img src="/2018/11/09/thread2/vread.png" alt="volatile read"><br>适合用到volatile的场景：</li></ul><ol><li>对volatile写不依赖于当前的值（如自增自减）</li><li>该变量不被包含在具有其他变量的式子中<br>所以可见他比较适合做标记量（如IO操作的完成标记，如下图：）<br><img src="/2018/11/09/thread2/vuse.png" alt="volatile use"></li></ol><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从Java源代码到最终实际执行的指令序列，会依次经过这三种重排序：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>对于某些Happen-before原则的操作，是无须额外操作便能达到有序性的：</p><ol><li>程序次序规则：<strong>一个线程</strong>内，按照代码执行，书写在前面的操作必定先行发生于书写在后面的操作。</li><li>锁定规则：一个unlock操作必定先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行必定发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A必定先行发生于操作C</li><li>线程启动原则：Thread对象的start()方法必定先行发生于此线程的每一个动作</li><li>线程中断规则:对线程interrupt()方法的调用必定先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()方法返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成必定先行发生于他的finalize()方法的开始</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Java的内存划分"><a href="#Java的内存划分" class="headerlink" title="Java的内存划分"></a>Java的内存划分</h3><p><img src="/2018/11/09/thread2/JVMM.jpg" alt="JVM Memory"><br>&nbsp;&nbsp;&nbsp;&nbsp;左边和右边有时也被称为堆区和栈区，相对Java内存模型来看其实差不多，跟我们平时所说的堆和栈，都可以运用。虽然这个清不清楚不会太影响这里解释Java内存模型，对于JVM内存划分想要详情了解的可以参考别的大佬的博客：<a href="https://www.cnblogs.com/zhguang/p/3257367.html" target="_blank" rel="noopener">Java内存区域划分</a></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的<strong>流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h4 id="Java-虚拟机栈-（栈）"><a href="#Java-虚拟机栈-（栈）" class="headerlink" title="Java 虚拟机栈 （栈）"></a>Java 虚拟机栈 （栈）</h4><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的<strong>对象实例以及数组</strong>都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等</strong>数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>虽然没有在图上显示，但其实JVM在<strong>堆和方法区里</strong>里分别开辟了一部分区域用来放常量池。</p><p><img src="/2018/11/09/thread2/ConstantPool.jfif" alt="img"></p><p>比较麻烦的是字符串常量：在编译阶段就把所有的字符串文字放到一个常量池中。</p><p>那么对于以下代码：</p><pre class=" language-java"><code class="language-java">     String str1 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>     String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre><p>解释就很清晰，第一行直接从常量池中取出对象，而第二行是在堆中创建了新的对象。</p><h3 id="计算机硬件架构的图示"><a href="#计算机硬件架构的图示" class="headerlink" title="计算机硬件架构的图示"></a>计算机硬件架构的图示</h3><p><img src="/2018/11/09/thread2/cpu.jpg" alt="CPU"><br>&nbsp;&nbsp;&nbsp;&nbsp;由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。但这里就会有一个问题，多个处理器进行处理如果发生同步的操作的时候就可能会出现数据错误，这时就需要有MESI这类缓存一致性协议了。具体可参考：<a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">维基百科对缓存一致性的介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程（一）——线程的介绍与创建</title>
      <link href="/2018/10/21/thread/"/>
      <url>/2018/10/21/thread/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><em>11.9已更新：ThreadPoolExecutor，下一次会更新更多线程池</em><br><em>这一篇作为Java线程系列的开篇吧，简单的介绍一下一些普遍的线程和线程的创建方式。</em></p><hr><h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><p>先放一张随处可见的线程状态转换图：<br><img src="/2018/10/21/thread/images/status.jpg" alt="Thread status"><br>所以啥是线程？<br>平时我们用的程序他运行起来了，他就叫进程（运行中的程序），是一个动态的概念，<br>而进程内部可能包含很多顺序执行任务，那这每一个任务就是一个线程。<br>进程和线程很类似，但又区别很大：</p><p>相同点：</p><ul><li><strong>进程的存在是为了让操作系统同时运行多个程序；线程的存在是为了让进程同时执行多个任务。</strong></li><li><strong>他们都可以并发执行</strong></li></ul><p>区别：</p><ul><li><strong>对于每一个进程系统都会分配一定内存空间与资源，而这些分配的内存空与资源在不同进程之间是很难共享的，所以说进程是地址独立、资源独立的；而对于每一个线程，他们只能共享进程中的资源，尤其是CPU（线程只有获得CPU才能够执行，说到底CPU也是系统分配给进程的）</strong></li><li><strong>一个程序至少要有一个进程，一个进程至少要有一个线程</strong></li></ul><p>为什么使用线程？</p><ul><li><strong>线程之间能共享资源，共享内存十分容易，而进程不行！</strong></li><li><strong>创建线程代价比创建进程要小得多，所以用多线程来实现多任务并发比多进程效率要高。</strong></li></ul><hr><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><p>除了众所周知的直接继承于Thread和实现Runnable的方法以外，还有Java 5后提供的Future+Callable和线程池，在这里写一下他们的方式与区别。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>直接通过继承于Thread的方式来创建：</p><ol><li>需要一个继承于Thread的类，并重写其中的run()方法</li><li>新建该类的对象</li><li>通过该对象的start()启动线程<pre><code>public class TestThread extends Thread{private int i ;//线程体@Overridepublic void run() {    for( ; i &lt;100 ; i++){       System.out.println(getName()+&quot; &quot;+i);    }}public static void main(String[] args) {    new TestThread().start();    new TestThread().start();}}</code></pre>此时输出的效果部分如下：<blockquote><p>Thread-1 42<br>Thread-0 66<br>Thread-0 67<br>Thread-1 43<br>Thread-1 44<br>Thread-0 68<br>Thread-1 45<br>Thread-0 69</p></blockquote></li></ol><p>可以看见，两个线程都混杂在一起，谁也不能影响到谁的变量i，这是以继承的方式。</p><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>Runnable的定义可以理解为该方法的反型封装，即它执行能做的事情。Runnable的创建线程的方式：</p><ol><li>需要一个实现Runnable的类，并实现其中的run()方法</li><li>创建这个类的实例，作为参数创建一个新的Thread对象</li><li>通过该对象的start()启动线程<pre><code>public class TestRunnable implements Runnable{//共用的成语属性private int i;//实现Runnable的run方法，线程体public void run() {    for (; i &lt; 100; i++) {        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);    }}public static void main(String[] args) {    TestRunnable tr = new TestRunnable();       //创建Runnable实例    new Thread(tr,&quot;Runnable-Thread1&quot;).start();  //传参构建Thread    new Thread(tr,&quot;Runnable-Thread2&quot;).start();}}</code></pre>部分输出效果：<blockquote><p>Runnable-Thread1 33<br>Runnable-Thread2 34<br>Runnable-Thread1 35<br>Runnable-Thread2 36<br>Runnable-Thread2 38<br>Runnable-Thread2 39<br>Runnable-Thread2 40<br>Runnable-Thread2 41<br>Runnable-Thread1 37</p></blockquote></li></ol><p>显然Thread1和Thread2明显共用了属性i，可见，当两个两个线程同时以同一个Runnable的实现类作为参数的时候，他们能共用那个Runnable的属性。（当然要是你创建两个Runnable实例效果会跟Thread一样，但是那样就没用Runnable的意义了）<br>但因为getName()是Thread类里的方法，所以必须用Thread的静态方法Thread.currentThread()先获得当前线程对象才能调用getName()。</p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable创建线程的方式跟Runnable很类似，虽然Thread的构造方法参数没有Callable类参数，但FutureTask实现了Runnable接口：</p><ol><li>需要一个实现Callable的类（Callable的泛型就是返回值的类型），并实现其中的call()方法</li><li>创建这个类的实例，作为参数包装成一个新的FutureTask对象</li><li>FutureTask作为参数创建一个新的Thread对象</li><li>通过该对象的start()启动线程</li><li><p>通过get()可以获得返回值（记得捕获异常）</p><pre><code>public class TestCallable implements Callable&lt;Integer&gt; {private int i;//线程体@Overridepublic Integer call(){    for(; i &lt; 100 ; i++){        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);    }    return i;}public static void main(String[] args) {    TestCallable tc = new TestCallable();       //创建Callable实例    FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(tc);        //包装成FutureTask    new Thread(task,&quot;Callable-Thread&quot;).start();             //当target传参进去    try {        System.out.println(&quot;返回值：&quot;+task.get());    } catch (Exception e) {        e.printStackTrace();    }}}</code></pre><p>部分输出效果：</p><blockquote><p>Callable-Thread 96<br>Callable-Thread 97<br>Callable-Thread 98<br>Callable-Thread 99<br>返回值：100</p></blockquote></li></ol><p>虽然用Callable创建起来比Runnable要复杂，但从这里可以看出来了：利用Callable不仅可以抛出异常，而且可以通过get()方法获得线程执行返回的信息。<br>其次要注意的是，这里我没有创建两个线程，只有一个主线程和一个Callable的线程，是因为使用同一个FutureTask来创建线程会被认为是“不安全的”，在Callable的线程体call()执行一次之后会将status改成不再是NEW，而不是NEW的callable将直接退出，无法执行线程体：</p><pre><code>public void run() {    if (state != NEW ||        !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread()))    return;</code></pre><p>所以如果用像前面Runnable那样用一个target创建两个线程的话，第二个线程将会在执行线程体之前就挂掉。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池Java5在之前只能自己手动去创建，现在已经有了多种方法如Executors工厂，ForkJoinPool，在这里先写Executors工厂类吧，利用线程池的方式：</p><ol><li>先调用Executors静态工厂方法创建一个ExecutorService或ScheduledExecutorService线程池对象（创建时可传入ThreadFactory来进行规定创建线程，下面CacheThreadPool会有例子）</li><li>创建Runnable/Callable实例，利用线程池对象的execute()和submit()或者schedule()来传入线程池并执行（callable必须用submit())</li><li>当任务完成后，执行shutdown()来关闭线程池</li></ol><p>附上一张线程池状态图：<br><img src="/2018/10/21/thread/images/poolstatus.jpg" alt="Thread Pool Status"></p><blockquote><p>其中newCacheThreadPool(), newFixedThreadPool(int nThreads), newSingleThreadExecutor()是ExecutorService对象，而newScheduledThreadPool(int corePoolSize), newSingleScheduledThreadPool()为ScheduledExecutorService对象，下面我会为前三个常用的做简单的例子。</p></blockquote><p>###<strong>FixedThreadPool</strong>：</p><pre><code>    public class PoolTest {        static class PoolRunnable implements Runnable{            private int i;            public void run() {                for (; i &lt; 100; i++) {                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);                }            }        }        public static void main(String[] args) {            ExecutorService executorService = Executors.newFixedThreadPool(3);            PoolRunnable p = new PoolRunnable();            executorService.execute(p);            executorService.submit(p);            executorService.shutdown();        }    }</code></pre><p>部分输出效果：</p><blockquote><p>pool-1-thread-1 41<br>pool-1-thread-2 45<br>pool-1-thread-1 46<br>pool-1-thread-2 47<br>pool-1-thread-2 49<br>pool-1-thread-2 50<br>pool-1-thread-2 51<br>pool-1-thread-2 52<br>pool-1-thread-1 48<br>pool-1-thread-2 53<br>pool-1-thread-1 54</p></blockquote><p>可见与用Runnable的方式效果相差无几，只是方式不一样了而已。<br>而三种Executor都有他们特别的地方，用<em>Thinking in Java</em>的原话来说的话就是这样：</p><blockquote><p>CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程的时候停止创建新线程，因此它是合理的Executor首选。只有在这种方式会引发问题的时候，才需要用到FixedThreadPool。<br>FixedThreadPool可以一次性预先执行代价高昂的线程分配，然后限制现成的数量不用每个任务都要付出创建线程的开销，直接从池中获取线程，且不会滥用可获得的资源。<br>SingleThreadExecutor就像是数量为1的FixedThreadPool，如果向它提交了多个任务，这些任务都将排队，所有任务将使用同一个进程。（但还是有区别，他提供了一种重要的并发保证，保证不会有两个线程被并发调用）</p></blockquote><p>###<strong>SingleThreadExecutord</strong>：</p><pre><code>public class PoolTest2 {    static class PoolRunnable2 implements Runnable{        public void run() {            int random = (int) Math.round(Math.random()*9+1);            System.out.println(&quot;我是&quot;+Thread.currentThread().getName()+&quot;, 我先睡&quot;+random+&quot;秒&quot;);            try {                Thread.sleep(random*1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName()+&quot;已经溜了&quot;);        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newSingleThreadExecutor();//换成newCachedThreadPool试试        for(int i = 0 ; i &lt; 5 ; i++) {            PoolRunnable2 p = new PoolRunnable2();            executorService.execute(p);        }        executorService.shutdown();    }}</code></pre><p>效果如图：</p><blockquote><p>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡7秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡5秒<br>pool-1-thread-1已经溜了</p></blockquote><p>可见该线程池中始终只有一个线程，一直使用的也是那一个线程。</p><p>###<strong>CacheThreadPool</strong><br>在利用线程池创建线程的时候我们很容易发现，几种创建线程池的方式都可以传入类型为ThreadFactory的参数，实际上线程池默认会有一个ThreadFactory的成员属性，当我们不传这个参数时默认为Executors.defaultThreadFactory()，里面包含了他所规定的创建线程时的操作：</p><pre><code>    static class DefaultThreadFactory implements ThreadFactory {        private static final AtomicInteger poolNumber = new AtomicInteger(1);        private final ThreadGroup group;        private final AtomicInteger threadNumber = new AtomicInteger(1);        private final String namePrefix;        DefaultThreadFactory() {            SecurityManager s = System.getSecurityManager();            group = (s != null) ? s.getThreadGroup() :                                  Thread.currentThread().getThreadGroup();            namePrefix = &quot;pool-&quot; +                          poolNumber.getAndIncrement() +                         &quot;-thread-&quot;;        }        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r,                                  namePrefix + threadNumber.getAndIncrement(),                                  0);            if (t.isDaemon())                t.setDaemon(false);            if (t.getPriority() != Thread.NORM_PRIORITY)                t.setPriority(Thread.NORM_PRIORITY);            return t;        }    }</code></pre><p>那么我们实际上也可以定义一个自己的ThreadFactory来<strong>定义线程池在创建线程时候的操作（这就是ThreadFactory的作用）</strong>。<br>在这里既然讲到了ThreadFactory，那么也顺带讲一讲线程的异常捕获吧。线程的异常由于线程的本质特性，使得不能捕获到线程中逃逸的异常（你大可以尝试在run中抛出一个异常，然后在main中尝试去捕获它），在Java SE5以前只能使用线程组进行捕获<del>（而线程组已被Sun公司的架构师表示——“最好把线程组看成是一次不成功的尝试，你只要忽略它就行了”）</del>，而Java SE5线程池的出现已经能完美的解决这一问题。<br>我们通过前面所提到的ThreadFactory能修改线程池生产线程的方式——在生产时候为每个Thread对象附上一个异常处理器UncaughtExceptionHandler，那么在抛出异常的时候便会通过处理器进行捕获处理：</p><pre><code>public class PoolTest3 {    static class ExecptionThread implements Runnable{        @Override        public void run() {            throw new RuntimeException();        }    }    static class EHThreadFactory implements ThreadFactory{        @Override        public Thread newThread(Runnable r) {            Thread t = new Thread(r);            t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {                @Override                public void uncaughtException(Thread t, Throwable e) {                    System.out.println(&quot;catch &quot; + e);                }            });//你也可以创建一个类继承于Thread.UncaughtExceptionHandler来进行使用而不使用匿名类            return t;        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newCachedThreadPool(new EHThreadFactory());        executorService.execute(new ExecptionThread());        executorService.shutdown();    }}</code></pre><p>效果如下</p><blockquote><p>catch java.lang.RuntimeException</p></blockquote><p>你甚至可以调用静态设置Thread.setDefaultUncaughtExceptionHandler()来让所有没有设置未捕获异常处理器的线程调用默认的未捕获异常处理器。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><strong>ThreadPoolExecutor</strong></h3><p>我们已经知道是通过工厂方法来创建的线程池，那那些线程池实际上都是什么？<br>只要你看了看源代码就知道，无论是创建Fixed的还是Cached的线程池，其实都是new 一个 ThreadPoolExecutor(但是是ExecutorService的实现，具体可看下图），只是他们new出的ThreadPoolExecutor参数不同。</p><p>如图可见他们的关系：<br><img src="/2018/10/21/thread/images/relation.jpg" alt="relation"></p><p>而他有以下几个核心参数用于初始化：</p><p>corePoolSize：核心线程数<br>maximumPoolSize：最大线程数<br>workQueue：阻塞队列，存储等待执行的任务，有三种<br>keepAlive：线程没有任务时最多保持多久才终止（单位为unit）<br>threadFactory：线程工厂，用来设置线程池生产线程的方式<br>rejectHandler：拒绝任务的时候的策略</p><p>他有几个可用于监控的重要方法：</p><p>getTaskCount()：获得线程池已执行和未执行的任务总数<br>getCompletedTaskCount()：获得以完成的任务数量<br>getPoolSize()：线程池中当前线程的数量<br>getActiveCount()：当前线程池中正在执行任务的线程数量</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>直接用Thread的方式创建多线程的优势：</p><p><strong>编程简单，像获得当前线程直接通过实例的方法即可，十分适合那些短小精悍的线程。</strong></p><p>用实现Runnable的方式创建多线程的优势：</p><p> <strong>1.能继承与实现更多的类</strong><br> <strong>2.能通过共用target来进行共享资源</strong></p><p>用实现Callable的方式创建多线程的优势：</p><p> <strong>1.能继承与实现更多的类</strong><br> <strong>2.能捕获异常进行处理</strong><br> <strong>3.能获得线程执行的返回值，在编程上能有更多空间</strong></p><p>用线程池的方式的优势：</p><p><strong>1.target通过submit()或schedule()传入线程池后，线程池会启用一个线程来执行target里的run()或call(),但执行结束后不会死亡，将进入空闲状态保留在线程池中，等待下一个target时使用。这样在创建大量的短暂线程的时候可以不用像Thraed那样用一个创建一个，性能差又浪费资源，直接从线程池中使用。</strong><br><strong>2.可以通过控制线程池的最大线程数来控制系统并发线程数，统一管理线程，防止线程创建过多占用过多系统资源而导致的JVM崩溃，也避免的资源竞争</strong><br><strong>3.利用ScheduledExecutorService能指定延迟或周期性的执行线程任务</strong><br><strong>4.集合Runnable和Callable的优点——能共享资源，能处理返回值等</strong><br><strong>5.使用Executor能明显感到线程与任务是不同的概念，因为它甚至替你创建与管理线程，他将用户提交与运行分离开来，当然你也可以通过ThreadFactory来自定义线程池中线程的创建方式</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HttpURLConnection和HttpClient简单上手</title>
      <link href="/2018/10/13/http-easy/"/>
      <url>/2018/10/13/http-easy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;最近做项目过程中要搞HTTP请求的时候总是只能用以前写好的URLUtil，略是僵硬，想起之前做安卓有用过okhttp和httpclient，试着在Java里用一用并对比一下他们的效果吧。</p><hr><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;原生Java自带的http请求方式，抽象类URLConnection是表示应用程序和URL之间的通信链接的所有类的超类。 该类的实例可以用于从URL引用的资源中读取和写入。而HttpURLConnection是最常用于进行Http链接的他的子类。<br>请求方式一般步骤（参考JDK文档）：</p><ol><li>通过在URL上调用openConnection方法创建连接对象。</li><li>设置参数和一般请求属性。 </li><li>使用connect方法实现与远程对象的实际连接。</li><li>远程对象变得可用。 可以访问头字段和远程对象的内容。</li></ol><h3 id="简单GET请求"><a href="#简单GET请求" class="headerlink" title="简单GET请求"></a>简单GET请求</h3><pre><code>public String getByConnection(String str) throws IOException {    //1.创建连接    URL url = new URL(str);    HttpURLConnection httpConn = (HttpURLConnection)url.openConnection();    //2.设置参数    httpConn.setRequestMethod(&quot;GET&quot;);       //请求类型    httpConn.setRequestProperty( &quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot; );  //请求属性    httpConn.setConnectTimeout(100000);     //连接超时时间    httpConn.setReadTimeout(100000);        //读取超时时间    httpConn.setDoInput(true);              //是否读入    httpConn.setDoOutput(true);             //是否输出    httpConn.setUseCaches(true);            //是否使用缓存    //3.连接    httpConn.connect();                     //其实会调用所以不必要用connect()    //4.访问连接内容    BufferedReader reader = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));    String line;    StringBuffer buffer = new StringBuffer();    while ((line = reader.readLine()) != null) {        buffer.append(line);    }    reader.close();    httpConn.disconnect();    return buffer.toString();}</code></pre><h3 id="进行上传文件"><a href="#进行上传文件" class="headerlink" title="进行上传文件"></a>进行上传文件</h3><p>之所以不写Post原因是上传文件实际上就是一种特殊的POST，只是比简单的POST要多上不少东西，对于简单的POST可以只是向连接的OutputStream中写入键值对便可以了（跟get没什么区别的话也没太多必要用POST)。</p><p>首先由于HttpURLConnection的局限性（他只是一个抽象类，没有什么特别的集成），对于上传文件这类”multipart/form-data”类型的请求类型只能由我们手动拼接Header <del>（我来组成头部！）</del>，所以在说如何用HttpURLConnection进行上传文件前先说说上传时的Header：</p><p>可见在这用POST上传图片实际上就是模拟表单上传，而这时需要有拼接请求体：<br><img src="/2018/10/13/http-easy/images/header.png" alt="Http Header"></p><ol><li>请求体中需要先以”—–一串随机数字(代码中用的是UUID的随机序列)\r\n(\r\n的作用是换行)”来上下分隔。所以在前后都要加上boundary</li><li>然后写入Content-Disposition:form-data;name=”<strong>(此处需要与服务器约定)</strong>“;filename=”<strong>文件名</strong>“;</li><li>通过InputStream写入HttpURLConnection的OutputStream中。</li><li>最后以”—–那一串数字–\r\n”结尾。</li></ol><pre><code>public String uploadByConnection(String str) throws IOException{    //1.创建连接    URL url = new URL(str);    HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();    //2.设置参数    String Boundary = UUID.randomUUID().toString();     //请求边界    httpConn.setRequestMethod(&quot;POST&quot;);                  //请求类型    httpConn.setRequestProperty(&quot;Charset&quot;, &quot;utf-8&quot;);    //请求属性    httpConn.setRequestProperty( &quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot;+Boundary ); //请求属性    httpConn.setConnectTimeout(100000);     //连接超时时间    httpConn.setReadTimeout(100000);        //读取超时时间    httpConn.setDoInput(true);              //是否读入    httpConn.setDoOutput(true);             //是否输出    httpConn.setUseCaches(true);            //是否使用缓存    //3.HTTP请求体    DataOutputStream out = new DataOutputStream(httpConn.getOutputStream());    out.writeUTF(&quot;Content-Disposition: form-data; name=\&quot;user_upload_icon\&quot;;filename=\&quot;foo.jpg\&quot;\r\n\r\n&quot;);    InputStream in = new FileInputStream(&quot;src/foo.jpg&quot;);    byte[] b = new byte[1024];    int l = 0;    while((l = in.read(b)) != -1) out.write(b,0,l); // 写入文件    out.writeUTF(&quot;\r\n--&quot;+Boundary+&quot;--\r\n&quot;);    out.flush();    out.close();    in.close();    //4.获取响应信息    BufferedReader reader = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));    String line;    StringBuffer buffer = new StringBuffer();    while ((line = reader.readLine()) != null) {        buffer.append(line);    }    reader.close();    httpConn.disconnect();    return buffer.toString();}</code></pre><hr><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;作为Apache下手开发的工具包，使用起来比JDK自带的更为轻松和简单，实现的功能也更多。<br>HttpCLient最关键的方法是执行HTTP请求的方法execute。只要把HTTP请求传入，就可以得到HTTP响应。<br>使用HttpClient请求一个Http请求的步骤为：</p><ol><li>创建一个HttpClient对象</li><li>创建一个Request对象</li><li>使用HttpClient来执行Request请求，得到对方的response</li><li>处理response</li><li>关闭HttpClient</li></ol><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;  &lt;artifactId&gt;httpclient&lt;/artifactId&gt;  &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;    &lt;version&gt;4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><pre><code>compile &#39;org.apache.httpcomponents:httpclient:4.5.6&#39;</code></pre><h3 id="简单的GET请求"><a href="#简单的GET请求" class="headerlink" title="简单的GET请求"></a>简单的GET请求</h3><pre><code>public String getByClient(String str) throws IOException {    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(1000).build();   //可以对请求进行各种配置    HttpGet httpGet = new HttpGet(str);                             //创建Get请求    httpGet.setConfig(requestConfig);                               //设置配置    CloseableHttpResponse response = client.execute(httpGet);       //通过Client执行请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这绝对是肉眼可见的代码量减少，而且步骤十分清晰。值得一提的是，HttpClient以前的构建方式已经废弃，不能使用了：<br><del>HttpClinet client = new HttpClient();</del></p><h3 id="简单的POST请求"><a href="#简单的POST请求" class="headerlink" title="简单的POST请求"></a>简单的POST请求</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Post请求HttpClient巧妙的设计了HttpEntity类，以它来实现Http请求时的请求体，而且可以以多种方式创建，以便实现各种Post请求如表格，文件等，简单Post请求则可以用简单键值对来创建。</p><pre><code>public static String postByClient(String str, String phone, String password) throws IOException{    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().           //对请求进行各种配置            setConnectTimeout(1000).setConnectionRequestTimeout(1000)            .setSocketTimeout(1000).setRedirectsEnabled(true).build();    List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;();    //以列表形式创建Post的键值对信息    list.add(new BasicNameValuePair(&quot;phone&quot;,phone));    list.add(new BasicNameValuePair(&quot;password&quot;, password));    UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list,&quot;utf-8&quot;);   //用列表创建表格编码实体    HttpPost httpPost = new HttpPost(str);                          //创建Post请求    httpPost.setConfig(requestConfig);                              //设置配置    httpPost.setEntity(entity);                                     //设置实体信息    CloseableHttpResponse response = client.execute(httpPost);      //执行post请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Post请求上传文件可以利用MultipartEntityBuilder来进行Http请求体的创建，利用addPart(key,body)的形式可以对多形式的value进行记入。</p><pre><code>public static String uploadByClient(String str) throws IOException{    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().           //对请求进行各种配置            setConnectTimeout(1000).setConnectionRequestTimeout(1000)            .setSocketTimeout(1000).setRedirectsEnabled(true).build();    FileBody body = new FileBody(new File(&quot;src/foo.jpg&quot;), ContentType.MULTIPART_FORM_DATA);    HttpEntity entity = MultipartEntityBuilder.create().addPart(&quot;user_upload_icon&quot;,body).build();   //直接用MultipartEntityBuilder创建HTTP实体    HttpPost httpPost = new HttpPost(str);                          //创建Post请求    httpPost.setConfig(requestConfig);                              //设置配置    httpPost.setEntity(entity);                                     //设置实体信息    CloseableHttpResponse response = client.execute(httpPost);      //执行post请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这次简单的说了一下HttpURLConnection和HttpClinet的get/post请求方式，而且也很明显比较可见HttpClient集成的东西，帮我们做到的东西。当然HttpClient可以做的事远远不止get/post请求，他还有各种强大的功能在背后，他的设计与效果是十分精湛的。可以参考下面的链接来看关于HttpClient的更多用法与解析。<br>&nbsp;&nbsp;&nbsp;&nbsp;除了HttpURLConnection和HttpClinet以外，还有许多的优秀网络框架，如okhttp，Volley等，在安卓端开发时备受好评。<del>(而且HttpClient在API 23后都不支持使用了）</del>当然像这样轻量级的框架在做简单请求操作的时候是完全足够的，对于其他的框架以后再看吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://kb.cnblogs.com/page/92320/" target="_blank" rel="noopener">ABOUT HEADER</a></li><li><a href="http://hc.apache.org/" target="_blank" rel="noopener">HTTPCLIENT</a></li><li><a href="https://blog.csdn.net/u011179993/article/details/47147909" target="_blank" rel="noopener">HTTPCLIENT TUTORIALS</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Json和Gson的介绍与简单使用</title>
      <link href="/2018/10/05/gson/"/>
      <url>/2018/10/05/gson/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson（又称Google Json）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Json的使用大部分人都会知道的一个轻量级库：<a href="https://github.com/stleary/JSON-java" target="_blank" rel="noopener">org.json</a>，现在仍旧有不少人用，不过他对于json格式到bean格式的转换设计的有缺陷而且麻烦（例如复杂类型转换），对于简单的Json序列化操作时如此<strong>轻量级</strong>的类库是个不错的选择。（毕竟轻量级且五脏俱全）<br>&nbsp;&nbsp;&nbsp;&nbsp;如今对于Json的类库比较广为人知的有<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">json-lib</a>、Jackson、阿里巴巴的 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">FastJson</a>、谷歌的 <a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>，json-lib依赖的包太多速度也慢就不提了，虽然FastJson在parseJson有算法上的先进性以至能大大提高其速度运作，而Jackson在速度上也相差不多，但Gson在对于复杂的类型转换上有更强的性能，对于标准化的类库来说，Gson更能被称为Json的神器，那么在本篇我会写关于org.json的简单使用与Gson的常见使用来比较两者的用途与用法。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章代码已上传到<a href="https://github.com/ChitoseYono/JsonTest" target="_blank" rel="noopener">github</a>，可以查看代码自己研究。</p><hr><h2 id="添加类库依赖"><a href="#添加类库依赖" class="headerlink" title="添加类库依赖"></a><strong>添加类库依赖</strong></h2><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p><strong>org.json</strong>:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.json&lt;/groupId&gt;    &lt;artifactId&gt;json&lt;/artifactId&gt;    &lt;version&gt;20180813&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>Gson</strong>:</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;  &lt;artifactId&gt;gson&lt;/artifactId&gt;  &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a><strong>Gradle</strong></h3><p><strong>org.json</strong>:</p><pre><code>compile group: &#39;org.json&#39;, name: &#39;json&#39;, version: &#39;20180813&#39;</code></pre><p><strong>Gson</strong>:</p><pre><code>dependencies {  implementation &#39;com.google.code.gson:gson:2.8.5&#39;}</code></pre><hr><h2 id="Json数据与Bean"><a href="#Json数据与Bean" class="headerlink" title="Json数据与Bean"></a><strong>Json数据与Bean</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在正式介绍前简单看看本章会用到的Json数据与相应的JavaBean：</p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Json数据例子中简单地囊括Json中所有的类型，包括字符串型(string)，数字型(number)，布尔型(true/false)，空型(null)和object型。</p><pre><code>{    &quot;name&quot;: &quot;Bruce Eckel&quot;,    &quot;age&quot;: 61,    &quot;male&quot;: true,    &quot;representative_books&quot;: [        &quot;Thinking in C++&quot;,        &quot;Thinking in Java&quot;    ],    &quot;job&quot;: {        &quot;company&quot;: &quot;MindView&quot;,        &quot;position&quot;: &quot;CEO&quot;    },    &quot;comment&quot;: null}</code></pre><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a><strong>JavaBean</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其中设置了books和representive_works有不同的key，来考察类库的兼容性。而且comment在这不当做属性，只当做返回json数据中的备注。</p><pre><code>public class Person {    String name;    int age;    boolean male;    String[] books;    Job job;    //构造方法，getter,setter省略}class Job {    String company;    String position;    //构造方法，getter,setter省略}</code></pre><hr><h2 id="org-json"><a href="#org-json" class="headerlink" title="org.json"></a><strong>org.json</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;先简单说说org.json的用法吧，他提供的类库十分简单，只有四个常用类一个异常类，其中最为常用的一个类就JSONObject，基本可以用这个类解决比较多的事，org.json的设定是将它里面的类用作存储功能。<br><img src="/2018/10/05/gson/images/json_doucment.jpg" alt="org.json&#39;s document"></p><h3 id="获取Json格式数据"><a href="#获取Json格式数据" class="headerlink" title="获取Json格式数据"></a><strong>获取Json格式数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其实利用org.json基本上就像是Map&lt;K,V&gt;一样取值存值而已。</p><p>JSONObject有几个常用的构造方法，那么我先使用JSONObject来进行序列化：</p><pre><code>    //字符串转Json    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representative_books\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    //传入Json格式字符串    System.out.println(&quot;构造参数为String类：&quot;+strJson);    //Map转Json    Map&lt;String,Object&gt; jsonMap = new HashMap&lt;String,Object&gt;();    jsonMap.put(&quot;name&quot;, &quot;Bruce Eckel&quot;);    jsonMap.put(&quot;age&quot;, 61);    jsonMap.put(&quot;male&quot;, true);    jsonMap.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));    jsonMap.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonMap.put(&quot;comment&quot;,null);    JSONObject mapJson = new JSONObject(jsonMap);   //传入Map类型              System.out.println(&quot;构造参数为Map类：&quot;  + mapJson);    //JavaBean转Json    Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));    JSONObject beanJson = new JSONObject(bruce);    //传入Bean类型        System.out.println(&quot;构造参数为Bean类：&quot; + beanJson);    //用无参构造方法传参数的方式    JSONObject jsonObject = new JSONObject();   //无参构造器    jsonObject.put(&quot;name&quot;,&quot;Bruce Eckel&quot;);    jsonObject.put(&quot;age&quot;, 61);    jsonObject.put(&quot;male&quot;, true);    jsonObject.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));  //此处用的是JSONObject    jsonObject.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonObject.put(&quot;comment&quot;, &quot;null&quot;);          //此处输入的是&quot;null&quot;    System.out.println(&quot;构造参数为空：&quot;+jsonObject);</code></pre><p>输出效果如下：</p><blockquote><p>构造参数为String类：{“name”:”Bruce Eckel”,”comment”:null,”representive_works”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Map类：{“name”:”Bruce Eckel”,”representive_work”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Bean类：{“books”:[“Thinking in C++”,”Thinking in Java”],”gender”:true,”name”:”Bruce Eckel”,”job”:{},”age”:61}</p></blockquote><blockquote><p>构造参数为空：{“representive_work”:[“Thinking in C++”,”Thinking in Java”],”name”:”Bruce Eckel”,”comment”:”null”,”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><p><strong>可见JSONObject来进行序列化有如下几点缺陷</strong>：</p><ol><li>得到的Json数据是无序的；</li><li>无论是Map还是JSONObject的put()方法都没办法直接放null值否则会被省略不作序列化；</li><li>JavaBean中的自定义类型属性无法被序列化。</li></ol><p><strong>对于第一点的解决方法</strong>：<br>org.json提供了一个有序的类JSONStringer，用法如下</p><pre><code>    JSONStringer jsonStringer = new JSONStringer();    jsonStringer.object();        jsonStringer.key(&quot;name&quot;);        jsonStringer.value(&quot;Bruce Eckel&quot;);        jsonStringer.key(&quot;age&quot;);        jsonStringer.value(61);        jsonStringer.key(&quot;male&quot;);        jsonStringer.value(true);;        jsonStringer.key(&quot;job&quot;);        jsonStringer.object();            jsonStringer.key(&quot;company&quot;);            jsonStringer.value(&quot;MindView&quot;);            jsonStringer.key(&quot;position&quot;);            jsonStringer.value(&quot;CEO&quot;);        jsonStringer.endObject();        jsonStringer.key(&quot;representative_works&quot;);        jsonStringer.array();            jsonStringer.value(&quot;Thinking in C++&quot;);            jsonStringer.value(&quot;Thinking in Java&quot;);        jsonStringer.endArray();        jsonStringer.key(&quot;comment&quot;);        jsonStringer.value(&quot;null&quot;);    jsonStringer.endObject();    System.out.println(jsonStringer.toString());</code></pre><p>输出效果如下</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”job”:{“company”:”MindView”,”position”:”CEO”},”representative_works”:[“Thinking in C++”,”Thinking in Java”],”comment”:”null”}</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然是麻烦了点(非常麻烦)…毕竟他是有序的。而且一般情况用JSONObject也是够的因为有序不一定有用，而且JSONStringer虽然较为麻烦，但是他对于多重嵌套的问题有很大帮助。但要注意object()和endObject()、array()和endArray()，一定要匹配，否则就会抛出JSONException异常。</p><p><strong>对于第二点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;JSONObject对于null的识别是有坑的，想要赋予值为空的属性时得以”null”的方式传入（可以参考上述无参的构造方式中传”null”的方法-第29行。）<br>那么问题来了，如果想传值为”null”的字符串怎么办？<br>那可能只能通过直接处理字符串的方式了：</p><pre><code>    jsonObject.toString.replaceAll(&quot;:null,&quot;, &quot;:\&quot;null\&quot;,&quot;) </code></pre><p><strong>对于第三点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;org.json库无法识别自定义属性，所以只好用嵌套的方式，即JSONObject里包含JSONObject的方式来代替。（可以参考上述无参构造方式中的job-第27行)</p><h3 id="获取Json的属性值"><a href="#获取Json的属性值" class="headerlink" title="获取Json的属性值"></a><strong>获取Json的属性值</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这里用回之前的JSONObject。org.json压根就没做反序列化，如果手动来做的话这样是比较快的方法了，如果不是为了演示用法真不想做一次，对比起任何一个类库即使是json-lib都比他方便多了。当然，如果你只是为了取得里面的部分数据绝对是可以使用org.json的。</p><pre><code>    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representive_works\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    // 传入字符串    JSONArray jsonArray = strJson.getJSONArray(&quot;representive_works&quot;);    List&lt;String&gt; lists = new ArrayList&lt;String&gt;();    for (int i = 0; i &lt; jsonArray.length(); i++) {        lists.add(i,jsonArray.optString(i));    }    String[] books = new String[2];    lists.toArray(books);    Job job = new Job(strJson.getJSONObject(&quot;job&quot;).getString(&quot;company&quot;), strJson.getJSONObject(&quot;job&quot;).getString(&quot;position&quot;));    Person bruce = new Person(strJson.getString(&quot;name&quot;),strJson.getInt(&quot;age&quot;),strJson.getBoolean(&quot;male&quot;), books, job);    System.out.println(bruce.name+&quot; &quot;+bruce.age+&quot; &quot;+bruce.male+&quot; &quot;+bruce.books[0]+&quot; &quot;+bruce.books[1]+&quot; &quot;+bruce.job.company+&quot; &quot;+bruce.job.position);</code></pre><p>输出效果如下</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><p>以上就是基本的org.json类库的使用方法了，当然还有像JsonTokener和JSONWritter之类的类，都是没什么必要的，基本用JSONObject、JSONStringer、JSONArray这几个类可以完成业务。这也是org.json轻便之处，如果只是少量的Json操作，那用org.json这种轻量级类库再适合不过了。</p><hr><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a><strong>Gson</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gson中最重要的类可能就是Gson类了，但Gson中是不像其他类那样以JSONObject这样像Map一样的类存储数据的，Gson相当于只为了使用其成员方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;在操作之前，记得前面设计数据key和JavaBean属性时名字有不同的吗？序列化时如果不作任何操作只会用回原来属性名，而Gson给出了用注解的方式来处理的方法：</p><pre><code>    @SerializedName(value = &quot;representative_books&quot;)</code></pre><p><img src="/2018/10/05/gson/images/json_anno.png" alt="Annotation to change SerializedName "><br>&nbsp;&nbsp;&nbsp;&nbsp;那么在序列化时就会给他自动命名为”representative_books”，反序列化的时候就自动识别key为”representative_books”的语句</p><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h3><p><em>序列化就是将JavaBean到Json字符串的过程</em></p><pre><code>        Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));        Gson gson = new Gson();        String json = gson.toJson(bruce);        System.out.println(json);</code></pre><p>输出效果</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”representative_books”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”}}</p></blockquote><hr><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><p><em>反序列化就是将字符串转换成JavaBean的过程</em></p><pre><code>        Gson gson = new Gson();        String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;        Person bruce = gson.fromJson(json, Person.class);        System.out.println(bruce.getName()+&quot; &quot;+bruce.getAge()+&quot; &quot;+bruce.isMale()+&quot; &quot;+bruce.getBooks()[0]+&quot; &quot;+bruce.getBooks()[1]+&quot; &quot;+bruce.getJob().company+&quot; &quot;+bruce.getJob().position);</code></pre><p>输出效果</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><hr><h3 id="获取Json数据"><a href="#获取Json数据" class="headerlink" title="获取Json数据"></a><strong>获取Json数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里可能就会说，org.json的前面两点实际上跟Gson的序列化反序列化不太一样吧，org.json是获取数据，Gson是直接序列化了，那如果我只是要获取数据Gson还得创一个JavaBean不更加麻烦吗？实际上是不一定要JavaBean的，相信谷歌设计者也不会这么蠢。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson作为Json的神器，也有一套类似的方法。但此前先说一些概念性的东西：</p><ol><li>Gson中也有一个叫JsonObject的类，跟之前org.json无论是名字（前面的是JSONObject）还是用处都很像（都是用来存储数据），但还是有不一样的地方。</li><li>Gson的JsonObject也支持通过Json字符串或者用addpProperty()方法（相当于前面JSONObject的put方法）来构建，因为麻烦第二种就不再演示了，大家可以自己去试一下。</li><li>存在JsonObject里的数据称为JsonElement，而JsonElement有四种类型（意思就是说这四个类都是继承于JsonElement的）：JsonPrimitive（相当于number或者string或者boolean)、JsonArray（任意类型的JsonElement的集合，也可以混合类型）、JsonNull（相当于null）、JsonObject（嵌套自己类型），更多的详情请麻烦看下面的例子吧：</li></ol><pre><code>    String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;    JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();    System.out.println(jsonObject.getAsJsonPrimitive(&quot;name&quot;));    System.out.println(jsonObject.getAsJsonArray(&quot;representative_books&quot;));    System.out.println(jsonObject.getAsJsonObject(&quot;job&quot;));</code></pre><p>输出效果如下</p><blockquote><p>“Bruce Eckel”<br>[“Thinking in C++”,”Thinking in Java”]<br>{“company”:”MindView”,”position”:”CEO”}</p></blockquote><p>而通过debug以上代码，效果如下图<br><img src="/2018/10/05/gson/images/json_element.png" class="[png]" title="The types of JsonElement"><br>从这里就能很清晰的看到Gson提供的JsonObject的用法和其类型的解释了。可见Gson对于Json数据获取也是比较方便的。</p><hr><h2 id="可见Gson的优势"><a href="#可见Gson的优势" class="headerlink" title="可见Gson的优势"></a>可见Gson的优势</h2><ol><li>解决了null的歧义问题，当序列化的时候，如果对象的某个字段为null，是不会输出到Json字符串中的。当反序列化的时候，某个字段在Json字符串中找不到对应的值，就会被赋值为null。</li><li>自定义类型自动转换，且利用注解能支持字段过滤，支持任意的复杂对象转换。</li><li>代码量明显大幅度减少。</li><li>定义了一套Json数据类型，能够生成可压缩和可读的Json的字符串输出。</li></ol><hr><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在这里已经大致说完org.json和Gson的基本用法和介绍了，但真的仅仅是基本用法，其实Gson还有更多的像自定义Gson配置，各种注解过滤等等，不过对于简单的Json数据转换已经比较足够去应用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;用了Gson之后对比起org.json，肉眼可见的代码量减少，而且在反序列化时对类型也毫无阻碍，不用换来换去。但是单纯是这一点点使用例子与介绍的话实际上很难完全展示出Gson全部魅力，这也仅仅只是冰山一角。有机会的话会试着写更多Gson的用法吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.json.org/" target="_blank" rel="noopener">ABOUT JSON</a></li><li><a href="https://stleary.github.io/JSON-java/" target="_blank" rel="noopener">org.json DOCUMENT</a></li><li><a href="https://blog.csdn.net/u013075699/article/details/77964344" target="_blank" rel="noopener">JSONOBJECT NULL SOLUTION</a></li><li><a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener">GSON USER GUIDE</a></li><li><a href="http://tool.oschina.net/apidocs/apidoc?api=gson2.2.2" target="_blank" rel="noopener">GSON DOCUMENT</a></li><li><a href="https://blog.csdn.net/vickyway/article/details/48157819" target="_blank" rel="noopener">COMPARISON AMONG JSON LIBRARY</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome to White Noise</title>
      <link href="/2018/09/28/white-noise/"/>
      <url>/2018/09/28/white-noise/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;Welcome to <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise - Chitose Yono Offical Blog</a>! The website is still in constructing and after a while you can enjoy my articles here. Though whether they’re writen in English or Chinese depends on my heart, maybe most of time there is Chinese version.</p><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo-list"></a>Todo-list</h3><ul><li>Navigator for articles √</li><li>Music bar √</li><li>Original background images for changing √</li><li>Domain binding for the blog √</li><li>Pin to top √</li><li>Gallery</li><li>Categories</li><li>After all of these finished, I’ll make a conclusion.</li></ul><h3 id="Chitose-Yono"><a href="#Chitose-Yono" class="headerlink" title="Chitose Yono"></a>Chitose Yono</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;An undergraduate majoring in Software Programing. Got a lot of interests including music, art, traveling and so on, so don’t expect such a introvert guy will fill the blog with barely programing.</p><h3 id="White-Noise"><a href="#White-Noise" class="headerlink" title="White Noise"></a>White Noise</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Article in <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise</a> will be include but not limited to</p><ul><li>Software programing</li><li>Music making</li><li>Vomit machine</li></ul><h3 id="Vomit-machine"><a href="#Vomit-machine" class="headerlink" title="Vomit machine"></a>Vomit machine</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;To talk about the surrounding naraku everyday just like vomitting the shit, so you may have to taste the fucking emotional words in it.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
