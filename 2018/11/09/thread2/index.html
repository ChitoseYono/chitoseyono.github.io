<!DOCTYPE HTML>
<html lang="zh-CN,en,default">
<head>
    <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="java,android,music,emotion,Chitose Yono, hexo-theme-matery">
    <meta name="description" content="我所追寻的自己，可能不存在梦里">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>White Noise -Chitose Yono Offical Blog-</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/gitment/gitment-default.css">
    <link rel="stylesheet" type="text/css" href="/libs/gitment/gitment.js">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/gitment.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
</head>

<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span"></span>
                    </a>
                </div>

                <a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">Index</a>
    </li>
    
    
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">Tags</a>
    </li>
    
    
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">Archives</a>
    </li>
    
    
    
    <li class="hide-on-med-and-down">
        <a href="/guestbook" class="waves-effect waves-light">Guestbook</a>
    </li>
    
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">
    <div class="mobile-head bg-color">
        
        <img src="/medias/sublogo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">White Noise</div>
        <div class="logo-desc">
            
            我所追寻的自己，可能不存在梦里
            
        </div>
    </div>
    <ul class="menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                <i class="fa fa-link fa-lg fa-fw"></i>Index
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                <i class="fa fa-link fa-lg fa-fw"></i>Tags
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                <i class="fa fa-link fa-lg fa-fw"></i>Archives
            </a>
        </li>
        
        <li>
            <a href="/guestbook" class="waves-effect waves-light">
                <i class="fa fa-link fa-lg fa-fw"></i>Guestbook
            </a>
        </li>
        
    </ul>
    <div class="social-link">
        <a href="https://github.com/chitoseyono" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub"
           data-position="top" data-delay="50">
            <i class="fa fa-github fa-lg"></i>
        </a>
        <a href="mailto:chitoseyono@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我"
           data-position="top" data-delay="50">
            <i class="fa fa-envelope fa-lg"></i>
        </a>
        <a href="https://weibo.com/2818513061/profile" class="tooltipped" data-tooltip="访问我的微博"
           data-position="top" data-delay="50">
            <i class="fa fa-weibo fa-lg"></i>
        </a>
    </div>
</div>

            </div>
        </div>
    </nav>
</header>



<div class="bg-cover post-cover" style="background-image: url('/medias/images/thread_fuck.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        <font size="6">Java线程（二）——JMM与线程安全</font>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<main class="content">

    <!-- 目录内容 -->
         

    <!-- 文章内容详情 -->
    <div id="artDetail" class="container">
        <div class="card">
            <div class="card-content article-info">
                
                <div class="article-tag">
                    
                    <a href="https://chitoseyono.com/tags/Java/" target="_blank"><span class="chip bg-color">Java</span></a>
                    
                    <a href="https://chitoseyono.com/tags/Thread/" target="_blank"><span class="chip bg-color">Thread</span></a>
                    
                </div>
                
                <div class="author-info">
                    <span>
                        <i class="fa fa-calendar fa-fw"></i>2018-11-09
                    </span>
                </div>
            </div>
            <hr>
            <div class="card-content article-card-content">
                <div id="articleContent">
                    <script src="/assets/js/APlayer.min.js"> </script><p><em>这一篇将涉及比较多底层知识，代码较少但都是干货。</em></p>
<hr>
<h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM (Java Memory Model)"></a><strong>JMM</strong> <em>(Java Memory Model)</em></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在讲线程安全之前必须提及Java内存模型，因为线程安全是与它息息相关的。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先，JMM是一个抽象的规范，它本身不存在，通过JMM，JVM虚拟机可以屏蔽掉各种硬件或者操作系统的差异，规范了JVM如何与计算机内存协同工作的、线程之间共享资源的方式（如一个线程如何看到其他线程修改后的变量，同步访问共享变量等）。<br><img src="/2018/11/09/thread2/JMMDetail.png" alt="JMM"><br>&nbsp;&nbsp;&nbsp;&nbsp;如图，Java内存模型规定了所有变量都存储在主内存中<em>（即图中的Heap，主内存有时候也称堆内存）</em>，即主内存是任何线程都能访问到的。</p>
<ul>
<li>存放：所有<strong>对象</strong>及他们的成员变量、数组元素、静态域</li>
<li>优点：他是运行时的数据区，运行时动态分配内存的，生存期不必实现确定，由Java垃圾回收管理</li>
<li>缺点：存取速度相对较慢</li>
<li>Tips：只有获得对象的引用的变量才能被获得该引用的线程所访问</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;JVM运行的单位（实体）实际上就是线程，每个线程创建时JVM都会为它分配一个私有的工作内存<em>（即图里的Thread Stack，它有时候也被称为线程栈）</em>，不同线程间无法访问，用于存放该线程拥有的变量。</p>
<ul>
<li>存放：基本类型<strong>变量</strong>（包括局部变量与方法变量等）以及对象的引用</li>
<li>优点：存取速度十分快，仅次于CPU的寄存器</li>
<li>缺点：生存期与大小必须事先确定</li>
<li>Tips：当要一个线程要引用一个变量的时候，实际上是该线程从主内存获得一份<strong>私有拷贝</strong>到工作内存中去，在写操作时会再写回。</li>
</ul>
<blockquote>
<p><strong>注意：必须搞清楚一件事是Java的内存划分与Java内存模型是不同层次的概念！</strong><br>关于Java的内存划分我会在本文最后放出相应的图示与解释。<br>此处JMM定义的主内存可以说是Java内存区域划分中的：堆与方法区<br>而工作内存则是：程序计数器、虚拟机栈及本地方法栈</p>
</blockquote>
<h3 id="同步八操作"><a href="#同步八操作" class="headerlink" title="同步八操作"></a>同步八操作</h3><p>图示为Java内存模型的操作：<br><img src="/2018/11/09/thread2/JMM.jpg" alt="JMM"><br><em>如果了解计算机的缓存一致性MESI的人应该能看得出来Java内存模型跟多处理机进行缓存一致性操作有异曲同工之妙，至于那是什么可以去搜一下或者看在本文最后的东西。</em></p>
<p><strong>lock(锁定)</strong>：作用于主内存，让主内存变量标示为某一线程的独占的状态。<br><em>当进行lock时会使工作内存中的该变量清空，在执行前需重新执行load和assign</em></p>
<p><strong>unlock(解锁)</strong>：作用于主内存，让主内存变量的独占状态解除，可以被其他线程锁定。<br>。<em>进行unlock必须先把该变量从之前锁定的线程的工作内存中同步到主内存</em></p>
<p><strong>read(读取)</strong>：作用于主内存的变量，把一个变量值从主内存读取到线程的工作内存中，以便于load的操作。<br><em>load与read不能单独出现！</em></p>
<p><strong>load(载入)</strong>：作用于工作内存的变量，把主内存read到的变量放入工作内存的变量副本中。<br><em>一个新变量是只能在主内存中诞生，不允许工作内存中用一个未被初始化的变量，即use和store之前必须有load和assign</em></p>
<p><strong>use(使用)</strong>：作用于工作内存的变量，将变量副本取出来到执行引擎中执行。</p>
<p><strong>assign(赋值)</strong>：作用于工作内存的变量，将执行引擎中收到的值赋予工作内存中的变量。<br><em>一个线程assign过的变量必须从工作内存写回主内存</em></p>
<p><strong>store(存储)</strong>：作用于工作内存的变量，将工作内存的变量存入主内存中，便于进行write操作。<br><em>store与write不能单独出现！</em></p>
<p><strong>write(写入)</strong>：作用于主内存的变量，把store的变量传到主内存的变量中。</p>
<p>当在多线程环境进行这同步八操作的时候，就有可能引致线程安全问题。那什么是线程安全？</p>
<h2 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程安全是指在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，得到预期想要的效果，不会出现数据污染等意外情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;而线程安全主要从三个方面来考察：原子性、可见性、有序性。</p>
<ul>
<li><strong>原子性</strong>：指不可分割性，互斥访问的操作（同一时刻只能有一个线程进行的操作）；</li>
<li><strong>可见性</strong>：指线程之间，一个线程对主内存修改的结果，另一个线程能马上正确的看到；</li>
<li><strong>有序性</strong>：一个线程观察其他线程的指令执行顺序，在必要的执行顺序错误则无序（CPU会为提高速度而进行乱序执行优化）。</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>因为前面讲了线程池真™好啊，这里就用线程池做例子了。</p>
<pre><code>public class ConcurrencyExample {

    //请求总数
    public static int clientTotal = 1000;

    //线程池大小
    public static int threadTotal = 50;

    //计数器
    private static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0 ; i &lt; clientTotal ; i++){
            executorService.execute(() -&gt; add());
        }
        executorService.shutdown();
        while(!executorService.isTerminated()) { Thread.sleep(100);}    //由于main可能先比线程池的任务执行的快，所以在这等待，让所有队列中的线程完成后再结束
        System.out.println(&quot;count (should be 1000) : &quot; + count);
    }

    private static void add(){
        count++;
    }
}
</code></pre><p> 很明显，这串代码就是为了用一千个任务（任务就是每个任务都给一个共享的count加1）得到一个一千的值，所以如果输出<code>count (should be 1000) : 1000</code>的话就是我们想看到的。那么就执行这代码几次试试：</p>
<blockquote>
<p>count (should be 1000) : 979<br> count (should be 1000) : 956<br> count (should be 1000) : 982<br> count (should be 1000) : 965<br> count (should be 1000) : 973</p>
</blockquote>
<p>没有一次是达到目的的，每次都比1000少那么点，那问题出在哪里了呢？</p>
<p>相信是个人都知道x++这种自增符的用处相当于x=x+1，即先取出x的值，计算x+1，并把这个值传入到x里。<br>这里既有读操作也有写操作，写操作依赖于读操作，而这整个x++并非是一个原子性的操作，所以很有可能会产生这样的情况：线程1读完x=1后线程1准备写x=2的时候，线程2还在读之前的x=1，然后线程2写的时候也是写x=2，那么这两个线程本应该加到3也只能加到2。</p>
<p>那么这样就很清楚了为什么会发生这样的线程不安全问题了。</p>
<p>关于原子性，有几个常见的解决方法：</p>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><pre><code>public class ConcurrencyExample {

    //请求总数
    public static int clientTotal = 1000;

    //允许同时并发执行数
    public static int threadTotal = 50;

    //计数器
    private static Integer count = 0;

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0 ; i &lt; clientTotal ; i++){
            executorService.execute(() -&gt; add());
        }
        executorService.shutdown();
        while(!executorService.isTerminated()) { Thread.sleep(100);}
        System.out.println(&quot;count (should be 1000) : &quot; + count);
    }

    private synchronized static void add(){
        count++;
    }

    //      这个也行：
    //      private static void add(){
    //      synchronized (ConcurrencyExample.class) {
    //        count++;
    //      }
    //  }

    //      但这个不行：
    //      private static void add(){
    //      synchronized (count) {
    //        count++;      //每次执行这个，count都默认指向一个新的变量，那么锁就失效了
    //      }
    //  }

}
</code></pre><blockquote>
<p>count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000</p>
</blockquote>
<p>通过synchronized关键字，使任何线程进入代码块之前获得同步监视器锁，其他线程将不能获得同步锁而只能等待直到锁的释放。这里方法同步，对调用该方法的实例上锁，每次只能由一个线程获得锁来访问add()方法，那么效果便就如我们所愿了。<br>但是synchronized有时并不能满足我们的需求，首先sync只有完成了锁定的代码段才会解锁（或者其他如异常抛出或者wait()），不可中，，而且他是一种基于JVM的隐式锁，若里面代码片段过于复杂的时候就会资源占用，在竞争激烈的时候会导致性能下降，那么反而失去了多线程的必要性。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Java SE5提供了一种显锁式锁：ReentrantLock，通过显示的调用lock与unlock的方式进行锁定</p>
<pre><code>public class ConcurrencyExample {

    //请求总数
    public static int clientTotal = 1000;

    //允许同时并发执行数
    public static int threadTotal = 50;

    //计数器
    private static int count = 0;

    private static final ReentrantLock lock  = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0 ; i &lt; clientTotal ; i++){
            executorService.execute(() -&gt; add());
        }
        executorService.shutdown();
        while(!executorService.isTerminated()) { Thread.sleep(100);}
        System.out.println(&quot;count (should be 1000) : &quot; + count);
    }

    private static void add(){
        lock.lock();
        count++;
        lock.unlock();
    }
}
</code></pre><p>实际上与synchronized没太多区别，主要是Lock有一个比较特别的多一个tryLock()，能让其他线程如果获得不到锁去做别的事，而能更灵活的使用锁。</p>
<h3 id="Atomic类"><a href="#Atomic类" class="headerlink" title="Atomic类"></a>Atomic类</h3><p>J.U.C(Java.util.concurrency)包内提供了一些十分有用的原子类如：AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference、LongAdder等<br>这里简单演示其中一个：</p>
<pre><code>public class ConcurrencyExample {

    //请求总数
    public static int clientTotal = 1000;

    //允许同时并发执行数
    public static int threadTotal = 50;

    //计数器
    private static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0 ; i &lt; clientTotal ; i++){
            executorService.execute(() -&gt; add());
        }
        executorService.shutdown();
        while(!executorService.isTerminated()) { Thread.sleep(100);}
        System.out.println(&quot;count (should be 1000) : &quot; + count.get());
    }

    private static void add(){
        count.incrementAndGet();        //相当于自增
    }
}
</code></pre><blockquote>
<p>count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000</p>
</blockquote>
<p> 在此AtomicInteger的原子类是线程安全的，这些原子类的实现都是基于一个CAS算法，我们可以看看那个AtomicInteger的内部：<br> <img src="/2018/11/09/thread2/CAS.png" alt="CAS?"><br> 然后再进去看看：<br> ，var1是传入的对象，var2是对象当前的值，var4为加数，var5是通过getIntVolatile()方法获得对象的底层值，通过在死循环里不停使用compareAndSwapInt（就是CAS）比较对象的当前值与其底层值，这里的compareAndSwapInt是Unsafe类中的一个native本地内部方法，若不相同则返回false，若相同则将其值更新为var5+var4。<br> <img src="/2018/11/09/thread2/CAS2.jpg" alt="CAS"><br> 原子类都是通过这种CAS算法来进行安全的修改。</p>
<p> 顺带讲一种用法，<br> <strong>懒汉单例模式</strong>：</p>
<pre><code> public class LazySingletonExample {

    private LazySingletonExample(){}

    private static LazySingletonExample instance = null;

    public static synchronized LazySingletonExample getInstance(){
        if(instance == null){
            instance = new LazySingletonExample();
        }
        return instance;
    }
}
</code></pre><p>这是懒汉单例模式的一种写法，而在这里通过给getInstance()工厂方法加上synchronized关键字才保证了线程安全，否则会可能导致返回错误值。<br>但是前面也提到了使用方法同步的方式实际上大大降低性能，因为同一时间只能有一个线程能访问对象，所以这种单例模式虽然是线程安全，但是并不推荐，那么我们可以在其之上进行改进，<br>双重同步锁单例模式：</p>
<pre><code>public class DoubleLazySingletonExample {

    private DoubleLazySingletonExample(){}

    private static DoubleLazySingletonExample instance = null;

    public static synchronized DoubleLazySingletonExample getInstance(){
        if(instance == null){                                           //**Mark1**
            synchronized (DoubleLazySingletonExample.class) {
                if(instance == null) {
                    instance = new DoubleLazySingletonExample();        //**Mark2**
                }
            }
        }
        return instance;
    }
}
</code></pre><p>通过在里面使用双重锁定来保证了性能的提高，在已经有对象的时候直接不进入sync代码块，不至于让线程一直等待而无法同时使用对象。但是这里仍然有缺陷，假设有这样的情况：<br>首先对象初始化的过程是这样的：</p>
<ol>
<li>分配对象内存空间</li>
<li>初始化对象</li>
<li><p>使对象指向内存<br>1和（2,3）是不会发生指令重排的，但若2.3.发生指令重排，Thread1完成了3，Thread在Mark1位置判断instance时，因为不为空返回了值，但实际上还是没有初始化，所以非线程安全。所以这时需要给instance加上volatile关键字就解决重排序的问题了，这时这个单例模式便是线程安全的且性能较高：</p>
<pre><code>public class DoubleLazySingletonExample {

private DoubleLazySingletonExample(){}

//volatile+双重同步锁
private volatile static DoubleLazySingletonExample instance = null;

public static synchronized DoubleLazySingletonExample getInstance(){
    if(instance == null){                                           //Mark1-Thread2
        synchronized (DoubleLazySingletonExample.class) {
            if(instance == null) {
                instance = new DoubleLazySingletonExample();        //Mark2-Thread1
            }
        }
    }
    return instance;
}
}
</code></pre></li>
</ol>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>对可见性可以举一个例子：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当线程1修改工作内存中的值的时候，必须要写回主内存才能被其他线程看到，但若没有写回就被线程2读的话，就会导致不可见。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由此易知，导致不可见的原因：</p>
<ul>
<li>线程的交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主内存间及时更新</li>
</ul>
<h3 id="synchronized-Lock"><a href="#synchronized-Lock" class="headerlink" title="synchronized/Lock"></a>synchronized/Lock</h3><p>如何用锁保证可见性应该是显而易见的了，但还是在这里顺便说一下锁的原理：</p>
<ul>
<li>每次获得锁之前，会将所有工作内存中该变量的值清空</li>
<li>每次释放锁之前，必须把工作内存中变量最新值写回主内存<br>通过这种方式便能保证其他线程读到的是线程改动后的最新值。</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile实际上是通过内存屏障禁止重排序来实现可见性的：</p>
<ul>
<li>对volatile变量进行write操作的时候，写后加入一条store屏障，将本地内存中共享变量刷到主内存去，那么store指令会在写操作后把最新的值强制刷新到主内存中。同时还会禁止cpu对代码进行重排序优化。这样就保证了值在主内存中是最新的。</li>
<li>对volatile变量进行read操作的时候，加入一条load屏障，load指令会在读操作前把内存缓存中的值清空后，再从主内存中读取最新的值。<br>实际上可以说是相当于volatile变量的操作是在主内存上进行操作的，因而时刻保证其最新值。<br><img src="/2018/11/09/thread2/vwrite.png" alt="volatile write"><br><img src="/2018/11/09/thread2/vread.png" alt="volatile read"><br>适合用到volatile的场景：</li>
</ul>
<ol>
<li>对volatile写不依赖于当前的值（如自增自减）</li>
<li>该变量不被包含在具有其他变量的式子中<br>所以可见他比较适合做标记量（如IO操作的完成标记，如下图：）<br><img src="/2018/11/09/thread2/vuse.png" alt="volatile use"></li>
</ol>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从Java源代码到最终实际执行的指令序列，会依次经过这三种重排序：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>对于某些Happen-before原则的操作，是无须额外操作便能达到有序性的：</p>
<ol>
<li>程序次序规则：<strong>一个线程</strong>内，按照代码执行，书写在前面的操作必定先行发生于书写在后面的操作。</li>
<li>锁定规则：一个unlock操作必定先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行必定发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A必定先行发生于操作C</li>
<li>线程启动原则：Thread对象的start()方法必定先行发生于此线程的每一个动作</li>
<li>线程中断规则:对线程interrupt()方法的调用必定先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()方法返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成必定先行发生于他的finalize()方法的开始</li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Java的内存划分"><a href="#Java的内存划分" class="headerlink" title="Java的内存划分"></a>Java的内存划分</h3><p><img src="/2018/11/09/thread2/JVMM.jpg" alt="JVM Memory"><br>&nbsp;&nbsp;&nbsp;&nbsp;左边和右边有时也被称为堆区和栈区，相对Java内存模型来看其实差不多，跟我们平时所说的堆和栈，都可以运用。虽然这个清不清楚不会太影响这里解释Java内存模型，对于JVM内存划分想要详情了解的可以参考别的大佬的博客：<a href="https://www.cnblogs.com/zhguang/p/3257367.html" target="_blank" rel="noopener">Java内存区域划分</a></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的<strong>流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h4 id="Java-虚拟机栈-（栈）"><a href="#Java-虚拟机栈-（栈）" class="headerlink" title="Java 虚拟机栈 （栈）"></a>Java 虚拟机栈 （栈）</h4><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p>
<ul>
<li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的<strong>对象实例以及数组</strong>都在这里分配内存。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等</strong>数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p>
<p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>虽然没有在图上显示，但其实JVM在<strong>堆和方法区里</strong>里分别开辟了一部分区域用来放常量池。</p>
<p><img src="/2018/11/09/thread2/ConstantPool.jfif" alt="img"></p>
<p>比较麻烦的是字符串常量：在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<p>那么对于以下代码：</p>
<pre class=" language-java"><code class="language-java">     String str1 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
     String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>
</code></pre>
<p>解释就很清晰，第一行直接从常量池中取出对象，而第二行是在堆中创建了新的对象。</p>
<h3 id="计算机硬件架构的图示"><a href="#计算机硬件架构的图示" class="headerlink" title="计算机硬件架构的图示"></a>计算机硬件架构的图示</h3><p><img src="/2018/11/09/thread2/cpu.jpg" alt="CPU"><br>&nbsp;&nbsp;&nbsp;&nbsp;由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。但这里就会有一个问题，多个处理器进行处理如果发生同步的操作的时候就可能会出现数据错误，这时就需要有MESI这类缓存一致性协议了。具体可参考：<a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">维基百科对缓存一致性的介绍</a></p>

                </div>
                <hr/>

                <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone, qq, weibo, douban"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

                <div class="reprint">
                    <p>
                        <span class="reprint-tip">转载请注明: </span>
                        <a href="https://chitoseyono.com" class="b-link-green">White Noise -Chitose Yono Offical Blog-</a>
                        <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                        <a href="/2018/11/09/thread2/" class="b-link-green">Java线程（二）——JMM与线程安全</a>
                    </p>
                </div>
            </div>
        </div>

        
        <link rel="stylesheet" href="/libs/gitment/gitment-default.css">
<link rel="stylesheet" href="/css/gitment.css">

<div class="gitment-card card" data-aos="fade-up">
    <div id="gitment-content" class="card-content"></div>
</div>

<script src="/libs/gitment/gitment.js"></script>
<script>
var gitment = new Gitment({
    id: 'Fri Nov 09 2018 17:51:56 GMT+0800',
    owner: 'ChitoseYono',
    repo: 'chitoseyono.github.io',
    oauth: {
        client_id: '999f7c73059996845f36',
        client_secret: '8c466460b56a73683ea40833c9d5dca6f530ce9c'
    }
});

gitment.render('gitment-content');
</script>
        

        

        

<article id="articles" class="container prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">上一篇</div>
            <div class="card">
                <a href="/2018/11/10/narcissistic/">
                    <div class="card-image">
                        
                        <img src="/medias/images/Narcissistic.jpg" class="responsive-img" alt="高位水仙花数算法优化">
                        
                        <span class="card-title">高位水仙花数算法优化</span>
                    </div>
                    <div class="card-content article-content">
                        <div class="summary">
                             算法思路：以三位的水仙花数为例——

432各位立方幂和为99，小于100，则不能使用；
433各位立方幂和为118，但118并不由4 3 3三个数组成，则不是水仙花数；
531各位立方和为153，且153由5 3 1组成，则是水仙花数；
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-calendar fa-fw"></i>2018-11-11
                            </span>
                            <span class="publish-author">
                                <i class="fa fa-user fa-fw"></i>
                                
                                Chitose Yono
                                
                            </span>
                        </div>
                    </div>
                    
                    <div class="card-action article-tags">
                        
                        <a href="https://chitoseyono.com/tags/Java/"><span class="chip bg-color">Java</span></a>
                        
                        <a href="https://chitoseyono.com/tags/算法/"><span class="chip bg-color">算法</span></a>
                        
                    </div>
                    
                </a>
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">下一篇</div>
            <div class="card">
                <a href="/2018/10/21/thread/">
                    <div class="card-image">
                        
                        <img src="/medias/images/thread.jpg" class="responsive-img" alt="Java线程（一）——线程的介绍与创建">
                        
                        <span class="card-title">Java线程（一）——线程的介绍与创建</span>
                    </div>
                    <div class="card-content article-content">
                        <div class="summary">
                             11.9已更新：ThreadPoolExecutor，下一次会更新更多线程池这一篇作为Java线程系列的开篇吧，简单的介绍一下一些普遍的线程和线程的创建方式。

线程简介先放一张随处可见的线程状态转换图：所以啥是线程？平时我们用的程序他运
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-calendar fa-fw"></i>2018-10-21
                            </span>
                            <span class="publish-author">
                                <i class="fa fa-user fa-fw"></i>
                                
                                Chitose Yono
                                
                            </span>
                        </div>
                    </div>
                    
                    <div class="card-action article-tags">
                        
                        <a href="https://chitoseyono.com/tags/Java/"><span class="chip bg-color">Java</span></a>
                        
                        <a href="https://chitoseyono.com/tags/Thread/"><span class="chip bg-color">Thread</span></a>
                        
                    </div>
                    
                </a>
            </div>
        </div>
        
    </div>
</article>
    </div>
</main>

<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;<a href="http://chitoseyono.com" target="_blank">&nbsp;Chitose Yono</a>&nbsp;|
            Published with <a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;|
            Theme by <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>&nbsp;|
            Visited <span id="busuanzi_value_site_uv"></span> times<br>
        </div>
        <div class="col s12 m4 l4 social-link">
            <a href="https://github.com/chitoseyono" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
                <i class="fa fa-github fa-lg"></i>
            </a>
            <a href="mailto:chitoseyono@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
                <i class="fa fa-envelope fa-lg"></i>
            </a>
            <a href="https://weibo.com/2818513061/profile" class="tooltipped" data-tooltip="访问我的Weibo" data-position="top" data-delay="50">
                <i class="fa fa-weibo fa-lg"></i>
            </a>
        </div>
         <a href="https://beian.miit.gov.cn/">粤ICP备2021135111号</a>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title">搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input" autofocus="">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-double-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/js/music.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
</body>
</html>